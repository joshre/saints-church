(() => {
  var __esm = (fn2, res) => function __init() {
    return fn2 && (res = (0, fn2[Object.keys(fn2)[0]])(fn2 = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[Object.keys(cb)[0]])((mod = {exports: {}}).exports, mod), mod.exports;
  };

  // node_modules/@tailwindplus/elements/dist/index.js
  function ko(e, o, t) {
    Ao.set(e, setTimeout(() => {
      Ao.has(e) && e.dispatchEvent(new lt("toggle", {cancelable: false, oldState: o, newState: t}));
    }, 0));
  }
  function rt(e) {
    return Se.get(e) || "hidden";
  }
  function Ve(e) {
    return [...e].pop();
  }
  function Pn(e) {
    let o = e.popoverTargetElement;
    if (!(o instanceof HTMLElement))
      return;
    let t = rt(o);
    e.popoverTargetAction === "show" && t === "showing" || e.popoverTargetAction === "hide" && t === "hidden" || (t === "showing" ? Ie(o, true, true) : me(o, false) && (it.set(o, e), Mt(o)));
  }
  function me(e, o) {
    return !(e.popover !== "auto" && e.popover !== "manual" && e.popover !== "hint" || !e.isConnected || o && rt(e) !== "showing" || !o && rt(e) !== "hidden" || e instanceof In && e.hasAttribute("open") || document.fullscreenElement === e);
  }
  function xo(e) {
    if (!e)
      return 0;
    let o = Q.get(document) || new Set(), t = F.get(document) || new Set();
    return t.has(e) ? [...t].indexOf(e) + o.size + 1 : o.has(e) ? [...o].indexOf(e) + 1 : 0;
  }
  function kn(e) {
    let o = Oo(e), t = On(e);
    return xo(o) > xo(t) ? o : t;
  }
  function We(e) {
    let o, t = F.get(e) || new Set(), n = Q.get(e) || new Set(), r = t.size > 0 ? t : n.size > 0 ? n : null;
    return r ? (o = Ve(r), o.isConnected ? o : (r.delete(o), We(e))) : null;
  }
  function To(e) {
    for (let o of e || [])
      if (!o.isConnected)
        e.delete(o);
      else
        return o;
    return null;
  }
  function Le(e) {
    return typeof e.getRootNode == "function" ? e.getRootNode() : e.parentNode ? Le(e.parentNode) : e;
  }
  function Oo(e) {
    for (; e; ) {
      if (e instanceof HTMLElement && e.popover === "auto" && Se.get(e) === "showing")
        return e;
      if (e = e instanceof Element && e.assignedSlot || e.parentElement || Le(e), e instanceof Rt && (e = e.host), e instanceof Document)
        return;
    }
  }
  function On(e) {
    for (; e; ) {
      let o = e.popoverTargetElement;
      if (o instanceof HTMLElement)
        return o;
      if (e = e.parentElement || Le(e), e instanceof Rt && (e = e.host), e instanceof Document)
        return;
    }
  }
  function So(e, o) {
    let t = new Map(), n = 0;
    for (let s of o || [])
      t.set(s, n), n += 1;
    t.set(e, n), n += 1;
    let r = null;
    function i(s) {
      if (!s)
        return;
      let a = false, l = null, u = null;
      for (; !a; ) {
        if (l = Oo(s) || null, l === null || !t.has(l))
          return;
        (e.popover === "hint" || l.popover === "auto") && (a = true), a || (s = l.parentElement);
      }
      u = t.get(l), (r === null || t.get(r) < u) && (r = l);
    }
    return i(e.parentElement || Le(e)), r;
  }
  function Dn(e) {
    return e.hidden || e instanceof Rt || (e instanceof HTMLButtonElement || e instanceof HTMLInputElement || e instanceof HTMLSelectElement || e instanceof HTMLTextAreaElement || e instanceof HTMLOptGroupElement || e instanceof HTMLOptionElement || e instanceof HTMLFieldSetElement) && e.disabled || e instanceof HTMLInputElement && e.type === "hidden" || e instanceof HTMLAnchorElement && e.href === "" ? false : typeof e.tabIndex == "number" && e.tabIndex !== -1;
  }
  function Cn(e) {
    if (e.shadowRoot && e.shadowRoot.delegatesFocus !== true)
      return null;
    let o = e;
    o.shadowRoot && (o = o.shadowRoot);
    let t = o.querySelector("[autofocus]");
    if (t)
      return t;
    {
      let i = o.querySelectorAll("slot");
      for (let s of i) {
        let a = s.assignedElements({flatten: true});
        for (let l of a) {
          if (l.hasAttribute("autofocus"))
            return l;
          if (t = l.querySelector("[autofocus]"), t)
            return t;
        }
      }
    }
    let n = e.ownerDocument.createTreeWalker(o, NodeFilter.SHOW_ELEMENT), r = n.currentNode;
    for (; r; ) {
      if (Dn(r))
        return r;
      r = n.nextNode();
    }
  }
  function Mn(e) {
    var o;
    (o = Cn(e)) == null || o.focus();
  }
  function Mt(e) {
    if (!me(e, false))
      return;
    let o = e.ownerDocument;
    if (!e.dispatchEvent(new lt("beforetoggle", {cancelable: true, oldState: "closed", newState: "open"})) || !me(e, false))
      return;
    let t = false, n = e.popover, r = null, i = So(e, Q.get(o) || new Set()), s = So(e, F.get(o) || new Set());
    if (n === "auto" && (Ht(F.get(o) || new Set(), t, true), he(i || o, t, true), r = "auto"), n === "hint" && (s ? (he(s, t, true), r = "hint") : (Ht(F.get(o) || new Set(), t, true), i ? (he(i, t, true), r = "auto") : r = "hint")), n === "auto" || n === "hint") {
      if (n !== e.popover || !me(e, false))
        return;
      We(o) || (t = true), r === "auto" ? (Q.has(o) || Q.set(o, new Set()), Q.get(o).add(e)) : r === "hint" && (F.has(o) || F.set(o, new Set()), F.get(o).add(e));
    }
    st.delete(e);
    let a = o.activeElement;
    e.classList.add(":popover-open"), Se.set(e, "showing"), nt.has(o) || nt.set(o, new Set()), nt.get(o).add(e), Do(it.get(e), true), Mn(e), t && a && e.popover === "auto" && st.set(e, a), ko(e, "closed", "open");
  }
  function Ie(e, o = false, t = false) {
    var n, r;
    if (!me(e, true))
      return;
    let i = e.ownerDocument;
    if (["auto", "hint"].includes(e.popover) && (he(e, o, t), !me(e, true)))
      return;
    let s = Q.get(i) || new Set(), a = s.has(e) && Ve(s) === e;
    if (Do(it.get(e), false), it.delete(e), t && (e.dispatchEvent(new lt("beforetoggle", {oldState: "open", newState: "closed"})), a && Ve(s) !== e && he(e, o, t), !me(e, true)))
      return;
    (n = nt.get(i)) == null || n.delete(e), s.delete(e), (r = F.get(i)) == null || r.delete(e), e.classList.remove(":popover-open"), Se.set(e, "hidden"), t && ko(e, "open", "closed");
    let l = st.get(e);
    l && (st.delete(e), o && l.focus());
  }
  function Hn(e, o = false, t = false) {
    let n = We(e);
    for (; n; )
      Ie(n, o, t), n = We(e);
  }
  function Ht(e, o = false, t = false) {
    let n = To(e);
    for (; n; )
      Ie(n, o, t), n = To(e);
  }
  function Lo(e, o, t, n) {
    let r = false, i = false;
    for (; r || !i; ) {
      i = true;
      let s = null, a = false;
      for (let l of o)
        if (l === e)
          a = true;
        else if (a) {
          s = l;
          break;
        }
      if (!s)
        return;
      for (; rt(s) === "showing" && o.size; )
        Ie(Ve(o), t, n);
      o.has(e) && Ve(o) !== e && (r = true), r && (n = false);
    }
  }
  function he(e, o, t) {
    var n, r;
    let i = e.ownerDocument || e;
    if (e instanceof Document)
      return Hn(i, o, t);
    if ((n = F.get(i)) != null && n.has(e)) {
      Lo(e, F.get(i), o, t);
      return;
    }
    Ht(F.get(i) || new Set(), o, t), (r = Q.get(i)) != null && r.has(e) && Lo(e, Q.get(i), o, t);
  }
  function Io(e) {
    if (!e.isTrusted)
      return;
    let o = e.composedPath()[0];
    if (!o)
      return;
    let t = o.ownerDocument;
    if (!We(t))
      return;
    let r = kn(o);
    if (r && e.type === "pointerdown")
      Ot.set(t, r);
    else if (e.type === "pointerup") {
      let i = Ot.get(t) === r;
      Ot.delete(t), i && he(r || t, false, true);
    }
  }
  function Do(e, o = false) {
    if (!e)
      return;
    Dt.has(e) || Dt.set(e, e.getAttribute("aria-expanded"));
    let t = e.popoverTargetElement;
    if (t instanceof HTMLElement && t.popover === "auto")
      e.setAttribute("aria-expanded", String(o));
    else {
      let n = Dt.get(e);
      n ? e.setAttribute("aria-expanded", n) : e.removeAttribute("aria-expanded");
    }
  }
  function Co() {
    return typeof HTMLElement < "u" && typeof HTMLElement.prototype == "object" && "popover" in HTMLElement.prototype;
  }
  function pe(e, o, t) {
    let n = e[o];
    Object.defineProperty(e, o, {value(r) {
      return n.call(this, t(r));
    }});
  }
  function Bn() {
    return typeof globalThis.CSSLayerBlockRule == "function";
  }
  function Nn() {
    let e = Bn();
    return `
${e ? "@layer popover-polyfill {" : ""}
  :where([popover]) {
    position: fixed;
    z-index: 2147483647;
    inset: 0;
    padding: 0.25em;
    width: fit-content;
    height: fit-content;
    border-width: initial;
    border-color: initial;
    border-image: initial;
    border-style: solid;
    background-color: canvas;
    color: canvastext;
    overflow: auto;
    margin: auto;
  }

  :where([popover]:not(.\\:popover-open)) {
    display: none;
  }

  :where(dialog[popover].\\:popover-open) {
    display: block;
  }

  :where(dialog[popover][open]) {
    display: revert;
  }

  :where([anchor].\\:popover-open) {
    inset: auto;
  }

  :where([anchor]:popover-open) {
    inset: auto;
  }

  @supports not (background-color: canvas) {
    :where([popover]) {
      background-color: white;
      color: black;
    }
  }

  @supports (width: -moz-fit-content) {
    :where([popover]) {
      width: -moz-fit-content;
      height: -moz-fit-content;
    }
  }

  @supports not (inset: 0) {
    :where([popover]) {
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
    }
  }
${e ? "}" : ""}
`;
  }
  function Ct(e) {
    let o = Nn();
    if (Te === null)
      try {
        Te = new CSSStyleSheet(), Te.replaceSync(o);
      } catch {
        Te = false;
      }
    if (Te === false) {
      let t = document.createElement("style");
      t.textContent = o, e instanceof Document ? e.head.prepend(t) : e.prepend(t);
    } else
      e.adoptedStyleSheets = [Te, ...e.adoptedStyleSheets];
  }
  function Mo() {
    if (typeof window > "u")
      return;
    window.ToggleEvent = window.ToggleEvent || lt;
    function e(l) {
      return l?.includes(":popover-open") && (l = l.replace(Rn, "$1.\\:popover-open")), l;
    }
    pe(Document.prototype, "querySelector", e), pe(Document.prototype, "querySelectorAll", e), pe(Element.prototype, "querySelector", e), pe(Element.prototype, "querySelectorAll", e), pe(Element.prototype, "matches", e), pe(Element.prototype, "closest", e), pe(DocumentFragment.prototype, "querySelectorAll", e), Object.defineProperties(HTMLElement.prototype, {popover: {enumerable: true, configurable: true, get() {
      if (!this.hasAttribute("popover"))
        return null;
      let l = (this.getAttribute("popover") || "").toLowerCase();
      return l === "" || l == "auto" ? "auto" : l == "hint" ? "hint" : "manual";
    }, set(l) {
      l === null ? this.removeAttribute("popover") : this.setAttribute("popover", l);
    }}, showPopover: {enumerable: true, configurable: true, value(l = {}) {
      Mt(this);
    }}, hidePopover: {enumerable: true, configurable: true, value() {
      Ie(this, true, true);
    }}, togglePopover: {enumerable: true, configurable: true, value(l = {}) {
      return typeof l == "boolean" && (l = {force: l}), Se.get(this) === "showing" && l.force === void 0 || l.force === false ? Ie(this, true, true) : (l.force === void 0 || l.force === true) && Mt(this), Se.get(this) === "showing";
    }}});
    let o = Element.prototype.attachShadow;
    o && Object.defineProperties(Element.prototype, {attachShadow: {enumerable: true, configurable: true, writable: true, value(l) {
      let u = o.call(this, l);
      return Ct(u), u;
    }}});
    let t = HTMLElement.prototype.attachInternals;
    t && Object.defineProperties(HTMLElement.prototype, {attachInternals: {enumerable: true, configurable: true, writable: true, value() {
      let l = t.call(this);
      return l.shadowRoot && Ct(l.shadowRoot), l;
    }}});
    let n = new WeakMap();
    function r(l) {
      Object.defineProperties(l.prototype, {popoverTargetElement: {enumerable: true, configurable: true, set(u) {
        if (u === null)
          this.removeAttribute("popovertarget"), n.delete(this);
        else if (u instanceof Element)
          this.setAttribute("popovertarget", ""), n.set(this, u);
        else
          throw new TypeError("popoverTargetElement must be an element or null");
      }, get() {
        if (this.localName !== "button" && this.localName !== "input" || this.localName === "input" && this.type !== "reset" && this.type !== "image" && this.type !== "button" || this.disabled || this.form && this.type === "submit")
          return null;
        let u = n.get(this);
        if (u && u.isConnected)
          return u;
        if (u && !u.isConnected)
          return n.delete(this), null;
        let p = Le(this), c = this.getAttribute("popovertarget");
        return (p instanceof Document || p instanceof Po) && c && p.getElementById(c) || null;
      }}, popoverTargetAction: {enumerable: true, configurable: true, get() {
        let u = (this.getAttribute("popovertargetaction") || "").toLowerCase();
        return u === "show" || u === "hide" ? u : "toggle";
      }, set(u) {
        this.setAttribute("popovertargetaction", u);
      }}});
    }
    r(HTMLButtonElement), r(HTMLInputElement);
    let i = (l) => {
      if (l.defaultPrevented)
        return;
      let u = l.composedPath(), p = u[0];
      if (!(p instanceof Element) || p?.shadowRoot)
        return;
      let c = Le(p);
      if (!(c instanceof Po || c instanceof Document))
        return;
      let g = u.find((v) => {
        var d;
        return (d = v.matches) == null ? void 0 : d.call(v, "[popovertargetaction],[popovertarget]");
      });
      if (g) {
        Pn(g), l.preventDefault();
        return;
      }
    }, s = (l) => {
      let u = l.key, p = l.target;
      !l.defaultPrevented && p && (u === "Escape" || u === "Esc") && he(p.ownerDocument, true, true);
    };
    ((l) => {
      l.addEventListener("click", i), l.addEventListener("keydown", s), l.addEventListener("pointerdown", Io), l.addEventListener("pointerup", Io);
    })(document), Ct(document);
  }
  function Ho() {
    return typeof HTMLButtonElement < "u" && "command" in HTMLButtonElement.prototype && "source" in ((globalThis.CommandEvent || {}).prototype || {});
  }
  function Ro() {
    document.addEventListener("invoke", (d) => {
      d.type == "invoke" && d.isTrusted && (d.stopImmediatePropagation(), d.preventDefault());
    }, true), document.addEventListener("command", (d) => {
      d.type == "command" && d.isTrusted && (d.stopImmediatePropagation(), d.preventDefault());
    }, true);
    function e(d, m, h = true) {
      Object.defineProperty(d, m, {...Object.getOwnPropertyDescriptor(d, m), enumerable: h});
    }
    function o(d) {
      return d && typeof d.getRootNode == "function" ? d.getRootNode() : d && d.parentNode ? o(d.parentNode) : d;
    }
    let t = new WeakMap(), n = new WeakMap();
    class r extends Event {
      constructor(m, h = {}) {
        super(m, h);
        let {source: w, command: y} = h;
        if (w != null && !(w instanceof Element))
          throw new TypeError("source must be an element");
        t.set(this, w || null), n.set(this, y !== void 0 ? String(y) : "");
      }
      get [Symbol.toStringTag]() {
        return "CommandEvent";
      }
      get source() {
        if (!t.has(this))
          throw new TypeError("illegal invocation");
        let m = t.get(this);
        if (!(m instanceof Element))
          return null;
        let h = o(m);
        return h !== o(this.target || document) ? h.host : m;
      }
      get command() {
        if (!n.has(this))
          throw new TypeError("illegal invocation");
        return n.get(this);
      }
      get action() {
        throw new Error("CommandEvent#action was renamed to CommandEvent#command");
      }
      get invoker() {
        throw new Error("CommandEvent#invoker was renamed to CommandEvent#source");
      }
    }
    e(r.prototype, "source"), e(r.prototype, "command");
    class i extends Event {
      constructor(m, h = {}) {
        throw super(m, h), new Error("InvokeEvent has been deprecated, it has been renamed to `CommandEvent`");
      }
    }
    let s = new WeakMap();
    function a(d) {
      Object.defineProperties(d.prototype, {commandForElement: {enumerable: true, configurable: true, set(m) {
        if (this.hasAttribute("invokeaction"))
          throw new TypeError("Element has deprecated `invokeaction` attribute, replace with `command`");
        if (this.hasAttribute("invoketarget"))
          throw new TypeError("Element has deprecated `invoketarget` attribute, replace with `commandfor`");
        if (m === null)
          this.removeAttribute("commandfor"), s.delete(this);
        else if (m instanceof Element) {
          this.setAttribute("commandfor", "");
          let h = o(m);
          o(this) === h || h === this.ownerDocument ? s.set(this, m) : s.delete(this);
        } else
          throw new TypeError("commandForElement must be an element or null");
      }, get() {
        if (this.localName !== "button")
          return null;
        if (this.hasAttribute("invokeaction") || this.hasAttribute("invoketarget"))
          return console.warn("Element has deprecated `invoketarget` or `invokeaction` attribute, use `commandfor` and `command` instead"), null;
        if (this.disabled)
          return null;
        if (this.form && this.getAttribute("type") !== "button")
          return console.warn("Element with `commandFor` is a form participant. It should explicitly set `type=button` in order for `commandFor` to work"), null;
        let m = s.get(this);
        if (m)
          return m.isConnected ? m : (s.delete(this), null);
        let h = o(this), w = this.getAttribute("commandfor");
        return (h instanceof Document || h instanceof ShadowRoot) && w && h.getElementById(w) || null;
      }}, command: {enumerable: true, configurable: true, get() {
        let m = this.getAttribute("command") || "";
        if (m.startsWith("--"))
          return m;
        let h = m.toLowerCase();
        switch (h) {
          case "show-modal":
          case "close":
          case "toggle-popover":
          case "hide-popover":
          case "show-popover":
            return h;
        }
        return "";
      }, set(m) {
        this.setAttribute("command", m);
      }}, invokeAction: {enumerable: false, configurable: true, get() {
        throw new Error("invokeAction is deprecated. It has been renamed to command");
      }, set(m) {
        throw new Error("invokeAction is deprecated. It has been renamed to command");
      }}, invokeTargetElement: {enumerable: false, configurable: true, get() {
        throw new Error("invokeTargetElement is deprecated. It has been renamed to command");
      }, set(m) {
        throw new Error("invokeTargetElement is deprecated. It has been renamed to command");
      }}});
    }
    let l = new WeakMap();
    Object.defineProperties(HTMLElement.prototype, {oncommand: {enumerable: true, configurable: true, get() {
      return p.takeRecords(), l.get(this) || null;
    }, set(d) {
      let m = l.get(this) || null;
      m && this.removeEventListener("command", m), l.set(this, typeof d == "object" || typeof d == "function" ? d : null), typeof d == "function" && this.addEventListener("command", d);
    }}});
    function u(d) {
      for (let m of d)
        m.oncommand = new Function("event", m.getAttribute("oncommand"));
    }
    let p = new MutationObserver((d) => {
      for (let m of d) {
        let {target: h} = m;
        m.type === "childList" ? u(h.querySelectorAll("[oncommand]")) : u([h]);
      }
    });
    p.observe(document, {subtree: true, childList: true, attributeFilter: ["oncommand"]}), u(document.querySelectorAll("[oncommand]"));
    function c(d) {
      if (d.defaultPrevented || d.type !== "click")
        return;
      let m = d.target.closest("button[invoketarget], button[invokeaction], input[invoketarget], input[invokeaction]");
      if (m && (console.warn("Elements with `invoketarget` or `invokeaction` are deprecated and should be renamed to use `commandfor` and `command` respectively"), m.matches("input")))
        throw new Error("Input elements no longer support `commandfor`");
      let h = d.target.closest("button[commandfor], button[command]");
      if (!h)
        return;
      if (h.form && h.getAttribute("type") !== "button")
        throw d.preventDefault(), new Error("Element with `commandFor` is a form participant. It should explicitly set `type=button` in order for `commandFor` to work. In order for it to act as a Submit button, it must not have command or commandfor attributes");
      if (h.hasAttribute("command") !== h.hasAttribute("commandfor")) {
        let A = h.hasAttribute("command") ? "command" : "commandfor", E = h.hasAttribute("command") ? "commandfor" : "command";
        throw new Error(`Element with ${A} attribute must also have a ${E} attribute to function.`);
      }
      if (h.command !== "show-popover" && h.command !== "hide-popover" && h.command !== "toggle-popover" && h.command !== "show-modal" && h.command !== "close" && !h.command.startsWith("--")) {
        console.warn(`"${h.command}" is not a valid command value. Custom commands must begin with --`);
        return;
      }
      let w = h.commandForElement;
      if (!w)
        return;
      let y = new r("command", {command: h.command, source: h, cancelable: true});
      if (w.dispatchEvent(y), y.defaultPrevented)
        return;
      let b = y.command.toLowerCase();
      if (w.popover) {
        let A = !w.matches(":popover-open");
        A && (b === "toggle-popover" || b === "show-popover") ? w.showPopover({source: h}) : !A && b === "hide-popover" && w.hidePopover();
      } else if (w.localName === "dialog") {
        let A = !w.hasAttribute("open");
        A && b === "show-modal" ? w.showModal() : !A && b === "close" && w.close();
      }
    }
    function g(d) {
      d.addEventListener("click", c, true);
    }
    function v(d, m) {
      let h = d.prototype.attachShadow;
      d.prototype.attachShadow = function(y) {
        let b = h.call(this, y);
        return m(b), b;
      };
      let w = d.prototype.attachInternals;
      d.prototype.attachInternals = function() {
        let y = w.call(this);
        return y.shadowRoot && m(y.shadowRoot), y;
      };
    }
    a(HTMLButtonElement), v(HTMLElement, (d) => {
      g(d), p.observe(d, {attributeFilter: ["oncommand"]}), u(d.querySelectorAll("[oncommand]"));
    }), g(document), Object.assign(globalThis, {CommandEvent: r, InvokeEvent: i});
  }
  function Bo() {
    if (typeof HTMLDialogElement != "function")
      return false;
    let e = false, o = document.createElement("dialog");
    return o.addEventListener("beforetoggle", (t) => {
      e = true, t.preventDefault();
    }), o.show(), e;
  }
  function No() {
    let e = new WeakMap();
    function o(s) {
      let a = s.open ? "closed" : "open", l = s.open ? "open" : "closed";
      if (e.has(s)) {
        let u = e.get(s);
        l = u.oldState, clearTimeout(u.id);
      }
      e.set(s, {oldState: l, id: setTimeout(() => {
        s.dispatchEvent(new ToggleEvent("toggle", {newState: a, oldState: l}));
      })});
    }
    let t = HTMLDialogElement.prototype.show, n = HTMLDialogElement.prototype.showModal, r = HTMLDialogElement.prototype.close;
    function i(s) {
      let a = new ToggleEvent("beforetoggle", {newState: "closed", oldState: "open", cancelable: false});
      s.dispatchEvent(a), s.open && o(s);
    }
    document.addEventListener("submit", (s) => {
      let a = s.target;
      if (a.method === "dialog") {
        let l = a.closest("dialog");
        l instanceof HTMLDialogElement && i(l);
      }
    }, true), Object.defineProperties(HTMLDialogElement.prototype, {show: {value() {
      if (this.open || this.matches(":popover-open, :modal") || !this.ownerDocument)
        return t.apply(this, arguments);
      let s = new ToggleEvent("beforetoggle", {newState: "open", oldState: "closed", cancelable: true});
      this.dispatchEvent(s) && (o(this), t.apply(this, arguments));
    }}, showModal: {value() {
      if (this.open || this.matches(":popover-open, :modal") || !this.isConnected || !this.ownerDocument)
        return n.apply(this, arguments);
      let s = new ToggleEvent("beforetoggle", {newState: "open", oldState: "closed", cancelable: true});
      if (this.dispatchEvent(s))
        return o(this), n.apply(this, arguments);
    }}, close: {value() {
      return !this.open && !this.matches(":popover-open, :modal") ? r.apply(this, arguments) : (i(this), r.apply(this, arguments));
    }}});
  }
  function at(e) {
    function o() {
      document.readyState !== "loading" && (e(), document.removeEventListener("DOMContentLoaded", o));
    }
    typeof window < "u" && typeof document < "u" && (document.addEventListener("DOMContentLoaded", o), o());
  }
  async function Fn(e) {
    await qn();
    for (let o of document.styleSheets)
      try {
        for (let t of o.rules)
          if (t.constructor.name === "CSSLayerStatementRule" && "nameList" in t && t.nameList.includes(e))
            return true;
      } catch {
      }
    return false;
  }
  async function qn() {
    await Promise.all(Array.from(document.querySelectorAll('link[rel="stylesheet"]')).map((e) => e.sheet ? Promise.resolve() : new Promise((o) => {
      e.addEventListener("load", () => o(), {once: true}), e.addEventListener("error", () => o(), {once: true});
    })));
  }
  function Pe(e) {
    "focus" in e && e.focus({focusVisible: ut});
  }
  function T(e, o) {
    typeof globalThis.customElements > "u" || customElements.get(e) === o || customElements.define(e, o);
  }
  function X() {
    let e = [], o = {addEventListener(t, n, r, i) {
      return t.addEventListener(n, r, i), o.add(() => t.removeEventListener(n, r, i));
    }, requestAnimationFrame(...t) {
      let n = requestAnimationFrame(...t);
      return o.add(() => cancelAnimationFrame(n));
    }, nextFrame(...t) {
      return o.requestAnimationFrame(() => o.requestAnimationFrame(...t));
    }, setTimeout(...t) {
      let n = setTimeout(...t);
      return o.add(() => clearTimeout(n));
    }, microTask(...t) {
      let n = {current: true};
      return queueMicrotask(() => {
        n.current && t[0]();
      }), o.add(() => {
        n.current = false;
      });
    }, style(t, n, r) {
      let i = t.style.getPropertyValue(n);
      return n.startsWith("--") ? t.style.setProperty(n, r) : Object.assign(t.style, {[n]: r}), this.add(() => {
        n.startsWith("--") ? t.style.setProperty(n, i) : Object.assign(t.style, {[n]: i});
      });
    }, add(t) {
      return e.includes(t) || e.push(t), () => {
        let n = e.indexOf(t);
        if (n >= 0)
          for (let r of e.splice(n, 1))
            r();
      };
    }, dispose() {
      for (let t of e.splice(0))
        t();
    }};
    return o;
  }
  function ke(e, o = () => []) {
    let t = false, n = null, r = X();
    return {start(i, s) {
      let a = [e, ...o()];
      t ? t = false : t = n !== null && n !== i, n = i;
      for (let l of a)
        Vn(l, () => {
          t || (i === "in" ? (l.dataset.transition = "", l.dataset.enter = "", l.dataset.closed = "", delete l.dataset.leave) : i === "out" && (l.dataset.transition = "", l.dataset.leave = "", delete l.dataset.enter));
        }, n !== null);
      r.nextFrame(() => {
        for (let l of a)
          t ? i === "in" ? (delete l.dataset.enter, delete l.dataset.closed, l.dataset.leave = "") : i === "out" && (delete l.dataset.leave, l.dataset.enter = "", l.dataset.closed = "") : i === "in" ? delete l.dataset.closed : i === "out" && (l.dataset.closed = "");
        r.requestAnimationFrame(() => {
          r.add(Wn(e, () => {
            if (!(t && a.some((l) => $n(l)))) {
              for (let l of a)
                delete l.dataset.transition, delete l.dataset.enter, delete l.dataset.closed, delete l.dataset.leave;
              n = null, s?.();
            }
          }));
        });
      });
    }, abort() {
      r.dispose(), t = false, n = null;
    }};
  }
  function Vn(e, o, t = false) {
    if (t) {
      o();
      return;
    }
    let n = e.style.transition;
    e.style.transition = "none", o(), e.offsetHeight, e.style.transition = n;
  }
  function Wn(e, o) {
    let t = X();
    if (!e)
      return t.dispose;
    let n = false;
    t.add(() => {
      n = true;
    });
    let r = e.getAnimations?.({subtree: true}).filter((i) => i instanceof CSSTransition) ?? [];
    return r.length === 0 ? (o(), t.dispose) : (Promise.allSettled(r.map((i) => i.finished)).then(() => {
      n || o();
    }), t.dispose);
  }
  function $n(e) {
    return (e.getAnimations?.() ?? []).some((t) => t instanceof CSSTransition && t.playState !== "finished");
  }
  function Bt(e, o, t) {
    return J(e, Oe(o, t));
  }
  function ft(e, o) {
    return typeof e == "function" ? e(o) : e;
  }
  function be(e) {
    return e.split("-")[0];
  }
  function dt(e) {
    return e.split("-")[1];
  }
  function Nt(e) {
    return e === "x" ? "y" : "x";
  }
  function Ft(e) {
    return e === "y" ? "height" : "width";
  }
  function se(e) {
    return Un.has(be(e)) ? "y" : "x";
  }
  function qt(e) {
    return Nt(se(e));
  }
  function Vo(e, o, t) {
    t === void 0 && (t = false);
    let n = dt(e), r = qt(e), i = Ft(r), s = r === "x" ? n === (t ? "end" : "start") ? "right" : "left" : n === "start" ? "bottom" : "top";
    return o.reference[i] > o.floating[i] && (s = _e(s)), [s, _e(s)];
  }
  function Wo(e) {
    let o = _e(e);
    return [ct(e), o, ct(o)];
  }
  function ct(e) {
    return e.replace(/start|end/g, (o) => Kn[o]);
  }
  function Gn(e, o, t) {
    switch (e) {
      case "top":
      case "bottom":
        return t ? o ? qo : Fo : o ? Fo : qo;
      case "left":
      case "right":
        return o ? jn : zn;
      default:
        return [];
    }
  }
  function $o(e, o, t, n) {
    let r = dt(e), i = Gn(be(e), t === "start", n);
    return r && (i = i.map((s) => s + "-" + r), o && (i = i.concat(i.map(ct)))), i;
  }
  function _e(e) {
    return e.replace(/left|right|bottom|top/g, (o) => _n[o]);
  }
  function Yn(e) {
    return {top: 0, right: 0, bottom: 0, left: 0, ...e};
  }
  function _o(e) {
    return typeof e != "number" ? Yn(e) : {top: e, right: e, bottom: e, left: e};
  }
  function ve(e) {
    let {x: o, y: t, width: n, height: r} = e;
    return {width: n, height: r, top: t, left: o, right: o + n, bottom: t + r, x: o, y: t};
  }
  function Ko(e, o, t) {
    let {reference: n, floating: r} = e, i = se(o), s = qt(o), a = Ft(s), l = be(o), u = i === "y", p = n.x + n.width / 2 - r.width / 2, c = n.y + n.height / 2 - r.height / 2, g = n[a] / 2 - r[a] / 2, v;
    switch (l) {
      case "top":
        v = {x: p, y: n.y - r.height};
        break;
      case "bottom":
        v = {x: p, y: n.y + n.height};
        break;
      case "right":
        v = {x: n.x + n.width, y: c};
        break;
      case "left":
        v = {x: n.x - r.width, y: c};
        break;
      default:
        v = {x: n.x, y: n.y};
    }
    switch (dt(o)) {
      case "start":
        v[s] -= g * (t && u ? -1 : 1);
        break;
      case "end":
        v[s] += g * (t && u ? -1 : 1);
        break;
    }
    return v;
  }
  async function Vt(e, o) {
    var t;
    o === void 0 && (o = {});
    let {x: n, y: r, platform: i, rects: s, elements: a, strategy: l} = e, {boundary: u = "clippingAncestors", rootBoundary: p = "viewport", elementContext: c = "floating", altBoundary: g = false, padding: v = 0} = ft(o, e), d = _o(v), h = a[g ? c === "floating" ? "reference" : "floating" : c], w = ve(await i.getClippingRect({element: (t = await (i.isElement == null ? void 0 : i.isElement(h))) == null || t ? h : h.contextElement || await (i.getDocumentElement == null ? void 0 : i.getDocumentElement(a.floating)), boundary: u, rootBoundary: p, strategy: l})), y = c === "floating" ? {x: n, y: r, width: s.floating.width, height: s.floating.height} : s.reference, b = await (i.getOffsetParent == null ? void 0 : i.getOffsetParent(a.floating)), A = await (i.isElement == null ? void 0 : i.isElement(b)) ? await (i.getScale == null ? void 0 : i.getScale(b)) || {x: 1, y: 1} : {x: 1, y: 1}, E = ve(i.convertOffsetParentRelativeRectToViewportRelativeRect ? await i.convertOffsetParentRelativeRectToViewportRelativeRect({elements: a, rect: y, offsetParent: b, strategy: l}) : y);
    return {top: (w.top - E.top + d.top) / A.y, bottom: (E.bottom - w.bottom + d.bottom) / A.y, left: (w.left - E.left + d.left) / A.x, right: (E.right - w.right + d.right) / A.x};
  }
  function pt() {
    return typeof window < "u";
  }
  function we(e) {
    return Yo(e) ? (e.nodeName || "").toLowerCase() : "#document";
  }
  function R(e) {
    var o;
    return (e == null || (o = e.ownerDocument) == null ? void 0 : o.defaultView) || window;
  }
  function _(e) {
    var o;
    return (o = (Yo(e) ? e.ownerDocument : e.document) || window.document) == null ? void 0 : o.documentElement;
  }
  function Yo(e) {
    return pt() ? e instanceof Node || e instanceof R(e).Node : false;
  }
  function q(e) {
    return pt() ? e instanceof Element || e instanceof R(e).Element : false;
  }
  function K(e) {
    return pt() ? e instanceof HTMLElement || e instanceof R(e).HTMLElement : false;
  }
  function Go(e) {
    return !pt() || typeof ShadowRoot > "u" ? false : e instanceof ShadowRoot || e instanceof R(e).ShadowRoot;
  }
  function Ce(e) {
    let {overflow: o, overflowX: t, overflowY: n, display: r} = V(e);
    return /auto|scroll|overlay|hidden|clip/.test(o + n + t) && !Qn.has(r);
  }
  function Qo(e) {
    return Xn.has(we(e));
  }
  function je(e) {
    return Jn.some((o) => {
      try {
        return e.matches(o);
      } catch {
        return false;
      }
    });
  }
  function mt(e) {
    let o = ht(), t = q(e) ? V(e) : e;
    return Zn.some((n) => t[n] ? t[n] !== "none" : false) || (t.containerType ? t.containerType !== "normal" : false) || !o && (t.backdropFilter ? t.backdropFilter !== "none" : false) || !o && (t.filter ? t.filter !== "none" : false) || er.some((n) => (t.willChange || "").includes(n)) || tr.some((n) => (t.contain || "").includes(n));
  }
  function Xo(e) {
    let o = Z(e);
    for (; K(o) && !ye(o); ) {
      if (mt(o))
        return o;
      if (je(o))
        return null;
      o = Z(o);
    }
    return null;
  }
  function ht() {
    return typeof CSS > "u" || !CSS.supports ? false : CSS.supports("-webkit-backdrop-filter", "none");
  }
  function ye(e) {
    return or.has(we(e));
  }
  function V(e) {
    return R(e).getComputedStyle(e);
  }
  function ze(e) {
    return q(e) ? {scrollLeft: e.scrollLeft, scrollTop: e.scrollTop} : {scrollLeft: e.scrollX, scrollTop: e.scrollY};
  }
  function Z(e) {
    if (we(e) === "html")
      return e;
    let o = e.assignedSlot || e.parentNode || Go(e) && e.host || _(e);
    return Go(o) ? o.host : o;
  }
  function Jo(e) {
    let o = Z(e);
    return ye(o) ? e.ownerDocument ? e.ownerDocument.body : e.body : K(o) && Ce(o) ? o : Jo(o);
  }
  function De(e, o, t) {
    var n;
    o === void 0 && (o = []), t === void 0 && (t = true);
    let r = Jo(e), i = r === ((n = e.ownerDocument) == null ? void 0 : n.body), s = R(r);
    if (i) {
      let a = gt(s);
      return o.concat(s, s.visualViewport || [], Ce(r) ? r : [], a && t ? De(a) : []);
    }
    return o.concat(r, De(r, [], t));
  }
  function gt(e) {
    return e.parent && Object.getPrototypeOf(e.parent) ? e.frameElement : null;
  }
  function tn(e) {
    let o = V(e), t = parseFloat(o.width) || 0, n = parseFloat(o.height) || 0, r = K(e), i = r ? e.offsetWidth : t, s = r ? e.offsetHeight : n, a = Ke(t) !== i || Ke(n) !== s;
    return a && (t = i, n = s), {width: t, height: n, $: a};
  }
  function $t(e) {
    return q(e) ? e : e.contextElement;
  }
  function Me(e) {
    let o = $t(e);
    if (!K(o))
      return $(1);
    let t = o.getBoundingClientRect(), {width: n, height: r, $: i} = tn(o), s = (i ? Ke(t.width) : t.width) / n, a = (i ? Ke(t.height) : t.height) / r;
    return (!s || !Number.isFinite(s)) && (s = 1), (!a || !Number.isFinite(a)) && (a = 1), {x: s, y: a};
  }
  function on(e) {
    let o = R(e);
    return !ht() || !o.visualViewport ? nr : {x: o.visualViewport.offsetLeft, y: o.visualViewport.offsetTop};
  }
  function rr(e, o, t) {
    return o === void 0 && (o = false), !t || o && t !== R(e) ? false : o;
  }
  function Ee(e, o, t, n) {
    o === void 0 && (o = false), t === void 0 && (t = false);
    let r = e.getBoundingClientRect(), i = $t(e), s = $(1);
    o && (n ? q(n) && (s = Me(n)) : s = Me(e));
    let a = rr(i, t, n) ? on(i) : $(0), l = (r.left + a.x) / s.x, u = (r.top + a.y) / s.y, p = r.width / s.x, c = r.height / s.y;
    if (i) {
      let g = R(i), v = n && q(n) ? R(n) : n, d = g, m = gt(d);
      for (; m && n && v !== d; ) {
        let h = Me(m), w = m.getBoundingClientRect(), y = V(m), b = w.left + (m.clientLeft + parseFloat(y.paddingLeft)) * h.x, A = w.top + (m.clientTop + parseFloat(y.paddingTop)) * h.y;
        l *= h.x, u *= h.y, p *= h.x, c *= h.y, l += b, u += A, d = R(m), m = gt(d);
      }
    }
    return ve({width: p, height: c, x: l, y: u});
  }
  function _t(e, o) {
    let t = ze(e).scrollLeft;
    return o ? o.left + t : Ee(_(e)).left + t;
  }
  function nn(e, o, t) {
    t === void 0 && (t = false);
    let n = e.getBoundingClientRect(), r = n.left + o.scrollLeft - (t ? 0 : _t(e, n)), i = n.top + o.scrollTop;
    return {x: r, y: i};
  }
  function ir(e) {
    let {elements: o, rect: t, offsetParent: n, strategy: r} = e, i = r === "fixed", s = _(n), a = o ? je(o.floating) : false;
    if (n === s || a && i)
      return t;
    let l = {scrollLeft: 0, scrollTop: 0}, u = $(1), p = $(0), c = K(n);
    if ((c || !c && !i) && ((we(n) !== "body" || Ce(s)) && (l = ze(n)), K(n))) {
      let v = Ee(n);
      u = Me(n), p.x = v.x + n.clientLeft, p.y = v.y + n.clientTop;
    }
    let g = s && !c && !i ? nn(s, l, true) : $(0);
    return {width: t.width * u.x, height: t.height * u.y, x: t.x * u.x - l.scrollLeft * u.x + p.x + g.x, y: t.y * u.y - l.scrollTop * u.y + p.y + g.y};
  }
  function sr(e) {
    return Array.from(e.getClientRects());
  }
  function lr(e) {
    let o = _(e), t = ze(e), n = e.ownerDocument.body, r = J(o.scrollWidth, o.clientWidth, n.scrollWidth, n.clientWidth), i = J(o.scrollHeight, o.clientHeight, n.scrollHeight, n.clientHeight), s = -t.scrollLeft + _t(e), a = -t.scrollTop;
    return V(n).direction === "rtl" && (s += J(o.clientWidth, n.clientWidth) - r), {width: r, height: i, x: s, y: a};
  }
  function ar(e, o) {
    let t = R(e), n = _(e), r = t.visualViewport, i = n.clientWidth, s = n.clientHeight, a = 0, l = 0;
    if (r) {
      i = r.width, s = r.height;
      let u = ht();
      (!u || u && o === "fixed") && (a = r.offsetLeft, l = r.offsetTop);
    }
    return {width: i, height: s, x: a, y: l};
  }
  function cr(e, o) {
    let t = Ee(e, true, o === "fixed"), n = t.top + e.clientTop, r = t.left + e.clientLeft, i = K(e) ? Me(e) : $(1), s = e.clientWidth * i.x, a = e.clientHeight * i.y, l = r * i.x, u = n * i.y;
    return {width: s, height: a, x: l, y: u};
  }
  function Zo(e, o, t) {
    let n;
    if (o === "viewport")
      n = ar(e, t);
    else if (o === "document")
      n = lr(_(e));
    else if (q(o))
      n = cr(o, t);
    else {
      let r = on(e);
      n = {x: o.x - r.x, y: o.y - r.y, width: o.width, height: o.height};
    }
    return ve(n);
  }
  function rn(e, o) {
    let t = Z(e);
    return t === o || !q(t) || ye(t) ? false : V(t).position === "fixed" || rn(t, o);
  }
  function fr(e, o) {
    let t = o.get(e);
    if (t)
      return t;
    let n = De(e, [], false).filter((a) => q(a) && we(a) !== "body"), r = null, i = V(e).position === "fixed", s = i ? Z(e) : e;
    for (; q(s) && !ye(s); ) {
      let a = V(s), l = mt(s);
      !l && a.position === "fixed" && (r = null), (i ? !l && !r : !l && a.position === "static" && !!r && ur.has(r.position) || Ce(s) && !l && rn(e, s)) ? n = n.filter((p) => p !== s) : r = a, s = Z(s);
    }
    return o.set(e, n), n;
  }
  function dr(e) {
    let {element: o, boundary: t, rootBoundary: n, strategy: r} = e, s = [...t === "clippingAncestors" ? je(o) ? [] : fr(o, this._c) : [].concat(t), n], a = s[0], l = s.reduce((u, p) => {
      let c = Zo(o, p, r);
      return u.top = J(c.top, u.top), u.right = Oe(c.right, u.right), u.bottom = Oe(c.bottom, u.bottom), u.left = J(c.left, u.left), u;
    }, Zo(o, a, r));
    return {width: l.right - l.left, height: l.bottom - l.top, x: l.left, y: l.top};
  }
  function pr(e) {
    let {width: o, height: t} = tn(e);
    return {width: o, height: t};
  }
  function mr(e, o, t) {
    let n = K(o), r = _(o), i = t === "fixed", s = Ee(e, true, i, o), a = {scrollLeft: 0, scrollTop: 0}, l = $(0);
    function u() {
      l.x = _t(r);
    }
    if (n || !n && !i)
      if ((we(o) !== "body" || Ce(r)) && (a = ze(o)), n) {
        let v = Ee(o, true, i, o);
        l.x = v.x + o.clientLeft, l.y = v.y + o.clientTop;
      } else
        r && u();
    i && !n && r && u();
    let p = r && !n && !i ? nn(r, a) : $(0), c = s.left + a.scrollLeft - l.x - p.x, g = s.top + a.scrollTop - l.y - p.y;
    return {x: c, y: g, width: s.width, height: s.height};
  }
  function Wt(e) {
    return V(e).position === "static";
  }
  function en(e, o) {
    if (!K(e) || V(e).position === "fixed")
      return null;
    if (o)
      return o(e);
    let t = e.offsetParent;
    return _(e) === t && (t = t.ownerDocument.body), t;
  }
  function sn(e, o) {
    let t = R(e);
    if (je(e))
      return t;
    if (!K(e)) {
      let r = Z(e);
      for (; r && !ye(r); ) {
        if (q(r) && !Wt(r))
          return r;
        r = Z(r);
      }
      return t;
    }
    let n = en(e, o);
    for (; n && Qo(n) && Wt(n); )
      n = en(n, o);
    return n && ye(n) && Wt(n) && !mt(n) ? t : n || Xo(e) || t;
  }
  function gr(e) {
    return V(e).direction === "rtl";
  }
  function ln(e, o) {
    return e.x === o.x && e.y === o.y && e.width === o.width && e.height === o.height;
  }
  function br(e, o) {
    let t = null, n, r = _(e);
    function i() {
      var a;
      clearTimeout(n), (a = t) == null || a.disconnect(), t = null;
    }
    function s(a, l) {
      a === void 0 && (a = false), l === void 0 && (l = 1), i();
      let u = e.getBoundingClientRect(), {left: p, top: c, width: g, height: v} = u;
      if (a || o(), !g || !v)
        return;
      let d = Ue(c), m = Ue(r.clientWidth - (p + g)), h = Ue(r.clientHeight - (c + v)), w = Ue(p), b = {rootMargin: -d + "px " + -m + "px " + -h + "px " + -w + "px", threshold: J(0, Oe(1, l)) || 1}, A = true;
      function E(S) {
        let H = S[0].intersectionRatio;
        if (H !== l) {
          if (!A)
            return s();
          H ? s(false, H) : n = setTimeout(() => {
            s(false, 1e-7);
          }, 1e3);
        }
        H === 1 && !ln(u, e.getBoundingClientRect()) && s(), A = false;
      }
      try {
        t = new IntersectionObserver(E, {...b, root: r.ownerDocument});
      } catch {
        t = new IntersectionObserver(E, b);
      }
      t.observe(e);
    }
    return s(true), i;
  }
  function an(e, o, t, n) {
    n === void 0 && (n = {});
    let {ancestorScroll: r = true, ancestorResize: i = true, elementResize: s = typeof ResizeObserver == "function", layoutShift: a = typeof IntersectionObserver == "function", animationFrame: l = false} = n, u = $t(e), p = r || i ? [...u ? De(u) : [], ...De(o)] : [];
    p.forEach((w) => {
      r && w.addEventListener("scroll", t, {passive: true}), i && w.addEventListener("resize", t);
    });
    let c = u && a ? br(u, t) : null, g = -1, v = null;
    s && (v = new ResizeObserver((w) => {
      let [y] = w;
      y && y.target === u && v && (v.unobserve(o), cancelAnimationFrame(g), g = requestAnimationFrame(() => {
        var b;
        (b = v) == null || b.observe(o);
      })), t();
    }), u && !l && v.observe(u), v.observe(o));
    let d, m = l ? Ee(e) : null;
    l && h();
    function h() {
      let w = Ee(e);
      m && !ln(m, w) && t(), m = w, d = requestAnimationFrame(h);
    }
    return t(), () => {
      var w;
      p.forEach((y) => {
        r && y.removeEventListener("scroll", t), i && y.removeEventListener("resize", t);
      }), c?.(), (w = v) == null || w.disconnect(), v = null, l && cancelAnimationFrame(d);
    };
  }
  function pn(e, o) {
    let t = () => {
    };
    return function(r) {
      if (t(), !r) {
        e.style.removeProperty("position");
        return;
      }
      let i = o();
      if (!i || !e.hasAttribute("anchor"))
        return;
      let s = e.getAttribute("anchor"), a = e.getAttribute("anchor-strategy") || "absolute";
      a !== "absolute" && a !== "fixed" && (console.warn(`[createAnchorUpdater] Invalid anchor strategy "${a}" for element:`, e), a = "absolute"), t = an(i, e, () => {
        let l = dn(window.getComputedStyle(e).getPropertyValue("--anchor-gap"), e), u = dn(window.getComputedStyle(e).getPropertyValue("--anchor-offset"), e), p = s.split(" ")[0], c = {};
        switch (p) {
          case "top":
          case "bottom":
            c = {top: l, left: -1 * u, right: u, bottom: l};
            break;
          case "left":
          case "right":
            c = {top: -1 * u, bottom: u, left: l, right: l};
            break;
        }
        fn(i, e, {strategy: a, placement: s.replace(" ", "-"), middleware: [cn({padding: c}), un({padding: c})]}).then(async ({x: g, y: v, placement: d}) => {
          if (!vr() && a === "absolute") {
            let w = null;
            for (let y = e.parentElement; y; y = y.parentElement) {
              let b = getComputedStyle(y).position;
              if (b === "relative" || b === "absolute" || b === "fixed" || b === "sticky") {
                w = y;
                break;
              }
            }
            if (w) {
              let y = w.getBoundingClientRect();
              g -= y.left + window.scrollX, v -= y.top + window.scrollY;
            }
          }
          let m = `${g}px`, h = `${v}px`;
          switch (d.split("-")[0]) {
            case "top":
              h = `calc(${v}px - var(--anchor-gap, 0px))`, m = `calc(${g}px + var(--anchor-offset, 0px))`;
              break;
            case "right":
              m = `calc(${g}px + var(--anchor-gap, 0px))`, h = `calc(${v}px + var(--anchor-offset, 0px))`;
              break;
            case "bottom":
              h = `calc(${v}px + var(--anchor-gap, 0px))`, m = `calc(${g}px + var(--anchor-offset, 0px))`;
              break;
            case "left":
              m = `calc(${g}px - var(--anchor-gap, 0px))`, h = `calc(${v}px + var(--anchor-offset, 0px))`;
              break;
          }
          Object.assign(e.style, {left: m, top: h, position: a}), await Kt.isRTL?.(e) && Object.assign(e.style, {right: "unset", bottom: "unset"});
        });
      });
    };
  }
  function vr() {
    return "showPopover" in HTMLElement.prototype && HTMLElement.prototype.showPopover.toString().includes("[native code]");
  }
  function dn(e, o) {
    let t = document.createElement("div");
    o.appendChild(t), t.style.setProperty("margin-top", "0px", "important"), t.style.setProperty("margin-top", e, "important");
    let n = parseFloat(window.getComputedStyle(t).marginTop) || 0;
    return o.removeChild(t), n;
  }
  function Ge(e) {
    return Ut(e) && "tabIndex" in e;
  }
  function Ut(e) {
    return wr(e) && "tagName" in e;
  }
  function jt(e) {
    return Ut(e) && "accessKey" in e;
  }
  function wr(e) {
    return typeof e != "object" || e === null ? false : "nodeType" in e;
  }
  function mn(e) {
    return Ut(e) && "style" in e;
  }
  function hn(e) {
    return jt(e) && e.nodeName === "INPUT";
  }
  function B(e) {
    let o = e.getBoundingClientRect();
    return !(!(o.x !== 0 || o.y !== 0 || o.width !== 0 || o.height !== 0) || (e.ownerDocument.defaultView || window).getComputedStyle(e).visibility === "hidden");
  }
  function le(e, o, t) {
    function n() {
      if (!B(e)) {
        for (let r of e.children)
          if (B(r))
            return;
        t();
      }
    }
    if (typeof ResizeObserver < "u") {
      let r = new ResizeObserver(n);
      r.observe(e), o.addEventListener("abort", () => r.disconnect());
    }
    if (typeof IntersectionObserver < "u") {
      let r = new IntersectionObserver(n);
      r.observe(e), o.addEventListener("abort", () => r.disconnect());
    }
  }
  function He(e, o, t, n, r, i) {
    Er(e.ownerDocument);
    let s = ke(e), a = pn(e, t), l = X();
    e.setAttribute("popover", "");
    let u = o();
    u && (u.setAttribute("type", "button"), u.setAttribute("aria-haspopup", "true"), u.setAttribute("aria-controls", e.id), u.setAttribute("aria-expanded", "false"), u.id && e.setAttribute("aria-labelledby", u.id)), e.hasAttribute("open") && queueMicrotask(() => e.showPopover()), e.addEventListener("beforetoggle", (c) => {
      let g = c;
      a(g.newState === "open");
      let v = e.hasAttribute("open");
      g.newState === "open" && !v ? e.setAttributeNoCallbacks("open", "") : g.newState === "closed" && v && e.removeAttributeNoCallbacks("open"), g.newState === "open" ? (u?.setAttribute("aria-expanded", "true"), r?.(), Gt = e.getAttribute("popover") === "") : (u?.setAttribute("aria-expanded", "false"), i?.(), Gt = false), g.oldState === "closed" && g.newState === "open" ? (Ye && (l.dispose(), l = X()), s.start("in")) : g.oldState === "open" && g.newState === "closed" && (Ye && l.style(e, "transition-property", "none"), s.start("out"));
    }, {signal: n});
    function p() {
      e.hasAttribute("open") && e.hidePopover();
    }
    le(e, n, p), u && le(u, n, p), n.addEventListener("abort", () => s.abort());
  }
  function Er(e) {
    if (bn.has(e))
      return;
    bn.add(e);
    let o = null;
    e.addEventListener("mousedown", () => {
      zt || Ye || !Gt || (e.body.setAttribute("tabindex", "-1"), o && clearTimeout(o), o = setTimeout(() => e.body.removeAttribute("tabindex")));
    }, {capture: true});
  }
  function U(e, o, t, n) {
    function r() {
      let a = e.getBoundingClientRect();
      n.style.setProperty(o, a.width + "px");
    }
    let i = e.ownerDocument, s = new ResizeObserver(r);
    s.observe(e), i.addEventListener("transitionend", r, {signal: t}), t.addEventListener("abort", () => s.disconnect());
  }
  function P(e) {
    return `${e}-${Ar++}`;
  }
  function ae(e, o, t, n) {
    Tr(), e.addEventListener(o, (r) => {
      Yt !== null && Date.now() - Yt < xr || n(r);
    }, {passive: true, signal: t});
  }
  function Tr() {
    wn || (wn = true, document.addEventListener("keydown", () => {
      Yt = Date.now();
    }, {capture: true}));
  }
  function vt(e) {
    let o = yn.get(e);
    if (o.referenceCounter++, o.referenceCounter === 1) {
      let n = [Pr(), Lr(), Sr()];
      n.forEach(({before: r}) => r({doc: e, d: o.d})), n.forEach(({after: r}) => r({doc: e, d: o.d}));
    }
    let t = false;
    return () => {
      t || (t = true, o.referenceCounter--, !(o.referenceCounter > 0) && (o.d.dispose(), yn.delete(e)));
    };
  }
  function Sr() {
    return {before({doc: e, d: o}) {
      o.style(e.documentElement, "overflow", "hidden");
    }, after() {
    }};
  }
  function Lr() {
    let e;
    return {before({doc: o}) {
      let t = o.documentElement, n = o.defaultView ?? window;
      e = Math.max(0, n.innerWidth - t.clientWidth), t.style.setProperty("--el-top-layer-scrollbar-offset", "0px");
    }, after({doc: o, d: t}) {
      let n = o.documentElement, r = Math.max(0, n.clientWidth - n.offsetWidth), i = Math.max(0, e - r);
      t.style(n, "paddingRight", `${i}px`), t.add(() => {
        n.style.setProperty("--el-top-layer-scrollbar-offset", `-${i}px`);
      });
    }};
  }
  function Ir() {
    return /iPhone/gi.test(window.navigator.platform) || /Mac/gi.test(window.navigator.platform) && window.navigator.maxTouchPoints > 0;
  }
  function Pr() {
    return Ir() ? {before({doc: e, d: o}) {
      function t(n) {
        return !!n.closest("[popover], dialog > *");
      }
      o.microTask(() => {
        if (window.getComputedStyle(e.documentElement).scrollBehavior !== "auto") {
          let i = X();
          i.style(e.documentElement, "scrollBehavior", "auto"), o.add(() => o.microTask(() => i.dispose()));
        }
        let n = window.scrollY ?? window.pageYOffset, r = null;
        o.addEventListener(e, "click", (i) => {
          if (Ge(i.target))
            try {
              let s = i.target.closest("a");
              if (!s)
                return;
              let {hash: a} = new URL(s.href), l = e.querySelector(a);
              Ge(l) && !t(l) && (r = l);
            } catch {
            }
        }, true), o.addEventListener(e, "touchstart", (i) => {
          if (Ge(i.target) && mn(i.target))
            if (t(i.target)) {
              let s = i.target;
              for (; s.parentElement && t(s.parentElement); )
                s = s.parentElement;
              o.style(s, "overscrollBehavior", "contain");
            } else
              o.style(i.target, "touchAction", "none");
        }), o.addEventListener(e, "touchmove", (i) => {
          if (Ge(i.target)) {
            if (hn(i.target))
              return;
            if (t(i.target)) {
              let s = i.target;
              for (; s.parentElement && s.dataset.tailwindplusPortal !== "" && !(s.scrollHeight > s.clientHeight || s.scrollWidth > s.clientWidth); )
                s = s.parentElement;
              s.dataset.tailwindplusPortal === "" && i.preventDefault();
            } else
              i.preventDefault();
          }
        }, {passive: false}), o.add(() => {
          let i = window.scrollY ?? window.pageYOffset;
          n !== i && window.scrollTo(0, n), r && r.isConnected && (r.scrollIntoView({block: "nearest"}), r = null);
        });
      });
    }, after() {
    }} : {before() {
    }, after() {
    }};
  }
  function wt(e, o) {
    let t = null;
    e.addEventListener("toggle", (n) => {
      n.newState === "open" ? t || (t = vt(e.ownerDocument)) : t && (t(), t = null);
    }, {signal: o}), o.addEventListener("abort", () => {
      t && (t(), t = null);
    });
  }
  function G(e, o, t) {
    let n = o ? e.indexOf(o) : null;
    switch (n === -1 && (n = null), t) {
      case 0: {
        for (let r = 0; r < e.length; r++)
          if (B(e[r]))
            return e[r];
        return null;
      }
      case 1: {
        for (let r = e.length - 1; r >= 0; r--)
          if (B(e[r]))
            return e[r];
        return null;
      }
      case 2: {
        if (n === null)
          return G(e, o, 1);
        for (let r = n - 1; r >= 0; r--)
          if (B(e[r]))
            return e[r];
        return null;
      }
      case 3: {
        if (n === null)
          return G(e, o, 0);
        for (let r = n + 1; r < e.length; r++)
          if (B(e[r]))
            return e[r];
        return null;
      }
      case 4:
        return null;
    }
  }
  function yt(e) {
    let o = e.innerText ?? "", t = e.cloneNode(true);
    if (!jt(t))
      return o;
    let n = false;
    for (let i of t.querySelectorAll('[hidden],[aria-hidden],[role="img"]'))
      i.remove(), n = true;
    let r = n ? t.innerText ?? "" : o;
    return En.test(r) && (r = r.replace(En, "")), r;
  }
  function An(e) {
    let o = e.getAttribute("aria-label");
    if (typeof o == "string")
      return o.trim();
    let t = e.getAttribute("aria-labelledby");
    if (t) {
      let n = t.split(" ").map((r) => {
        let i = document.getElementById(r);
        if (i) {
          let s = i.getAttribute("aria-label");
          return typeof s == "string" ? s.trim() : yt(i).trim();
        }
        return null;
      }).filter(Boolean);
      if (n.length > 0)
        return n.join(", ");
    }
    return yt(e).trim();
  }
  function kr(e, o, t) {
    document.addEventListener("click", (n) => {
      if (n.target === e) {
        let {clientX: i, clientY: s} = n, a = e.getBoundingClientRect();
        if (i >= a.left && i <= a.right && s >= a.top && s <= a.bottom)
          return;
        t(n);
        return;
      }
      let r = e.closest("dialog");
      if (r && r.contains(n.target) && !e.contains(n.target)) {
        t(n);
        return;
      }
      if (n.target === n.target.ownerDocument.documentElement) {
        t(n);
        return;
      }
    }, {signal: o, capture: true});
  }
  function Or(e, o, t) {
    e.addEventListener("keydown", (n) => {
      n.key === "Escape" && (n.defaultPrevented || t(n));
    }, {signal: o});
  }
  function xt(e, o, t, n, r) {
    let i = null;
    for (let a of o)
      a.addEventListener("pointerdown", (l) => {
        l.button === 0 && e.classList.contains(":popover-open") && (i = Date.now() + 100);
      }, {signal: n, capture: true});
    e.ownerDocument.addEventListener("focusin", (a) => {
      if (!t.hasAttribute("open"))
        return;
      let l = a.target, u = a.relatedTarget;
      l !== null && (i && Date.now() < i || e.contains(l) || o.some((p) => p.contains(l)) || r(u));
    }, {signal: n});
  }
  function Tt(e, o, t) {
    let n = null, r = "", i = null, s = null;
    e.id || (e.id = P(o.role));
    let a = o.getButton();
    a.id || (a.id = P(`${o.role}-button`)), He(e, () => o.getButton(), () => o.getButton(), t, () => o.onBeforeOpen(), () => {
      o.onBeforeClose(), d(), r = "", i && (clearTimeout(i), i = null);
    }), wt(e, t), e.setAttribute("popover", "manual"), e.setAttribute("role", o.role), a.setAttribute("popovertarget", e.id), a.setAttribute("aria-haspopup", o.role);
    function l() {
      let b = o.getItems(), A = {passive: true, signal: t}, E = o.role === "menu" ? "menuitem" : "option";
      for (let S of b)
        S.getAttribute("role") !== E && (S.id || (S.id = P("item")), S.setAttribute("role", E), S.setAttribute("tabIndex", "-1"), S.addEventListener("click", () => o.onItemClick(S), A), ae(S, "mouseover", t, () => v(S, false)), ae(S, "mouseout", t, () => d()));
    }
    l();
    let u = new MutationObserver(l);
    u.observe(e, {attributes: false, childList: true, subtree: true}), xt(e, [a], e, t, (b) => {
      b === null && (s = Date.now() + 100), e.hidePopover();
    });
    let p = null, c = false;
    a.addEventListener("pointerdown", (b) => {
      if (b.button === 0 && !a.matches(":disabled")) {
        if (b.pointerType === "touch") {
          c = true;
          return;
        }
        e.togglePopover(), p = Date.now();
      }
    }, {signal: t}), document.addEventListener("pointerup", (b) => {
      if (b.button !== 0 || a.matches(":disabled") || !e.hasAttribute("open"))
        return;
      if (Date.now() - (p ?? 0) > Dr) {
        let E = b.composedPath();
        if (E.includes(e)) {
          if (p !== null) {
            let S = m();
            S && S.click();
          }
          return;
        }
        for (let S of E) {
          if (!(S instanceof Element))
            continue;
          if ((S.getAttribute("commandfor") || S.getAttribute("popovertarget")) === e.id)
            return;
        }
        e.hidePopover();
      }
      p = null;
    }, {signal: t, capture: true}), a.addEventListener("click", (b) => {
      if (c) {
        c = false;
        return;
      }
      b.preventDefault(), b.stopPropagation();
    }, {signal: t});
    let g = null;
    e.addEventListener("beforetoggle", (b) => {
      let A = b;
      A.newState === "open" && A.oldState === "closed" && z.length > 0 && !g && (g = z[0]);
    }, {signal: t}), e.addEventListener("toggle", (b) => {
      let A = b;
      A.newState === "closed" && A.oldState === "open" && setTimeout(() => {
        !e.contains(document.activeElement) && document.activeElement !== document.body || s && Date.now() < s || (g && g !== document.activeElement && g.isConnected && Pe(g), g = null);
      });
    }, {signal: t}), t.addEventListener("abort", () => {
      i && (clearTimeout(i), i = null), u.disconnect();
    });
    function v(b, A = true) {
      let E = m();
      E !== null && E.setAttribute("tabIndex", "-1"), e.removeAttribute("tabIndex"), b.setAttribute("tabIndex", "0"), b.focus({preventScroll: true}), n = b, A && b.scrollIntoView({block: "nearest"});
    }
    function d() {
      let b = m();
      b !== null && b.setAttribute("tabIndex", "-1"), n = null, e.hasAttribute("open") && (e.setAttribute("tabIndex", "0"), e.focus());
    }
    function m() {
      return n;
    }
    function h(b, A = false) {
      if (b === "")
        return null;
      let E = o.getItems(), S = b.toLowerCase(), H = m(), ce = H ? E.indexOf(H) : -1;
      if (!A && H && ce !== -1 && B(H) && (H.textContent?.trim().toLowerCase() || "").startsWith(S))
        return H;
      for (let D = ce + 1; D < E.length; D++)
        if ((E[D].textContent?.trim().toLowerCase() || "").startsWith(S) && B(E[D]))
          return E[D];
      for (let D = 0; D <= ce; D++)
        if ((E[D].textContent?.trim().toLowerCase() || "").startsWith(S) && B(E[D]))
          return E[D];
      return null;
    }
    function w(b) {
      let A = r === "";
      i && (clearTimeout(i), i = null), r += b.toLowerCase();
      let E = h(r, A);
      E && v(E, true), i = setTimeout(() => {
        r = "", i = null;
      }, 350);
    }
    function y() {
      return r !== "";
    }
    return {ignoreNextFocusRestoration: () => s = Date.now() + 100, setActiveItem: v, clearActiveItem: d, getActiveItem: m, findItemBySearchQuery: h, handleSearchKey: w, hasActiveSearchQuery: y};
  }
  var Sn, Eo, Ln, C, kt, f, L, I, M, lt, Ao, Rt, In, nt, Q, F, Se, it, st, Ot, Dt, Po, Rn, Te, ut, ge, $e, ie, x, Oe, J, Ke, Ue, $, _n, Kn, Un, Fo, qo, jn, zn, Uo, jo, zo, Qn, Xn, Jn, Zn, er, tr, or, nr, ur, hr, Kt, un, cn, fn, gn, Ye, zt, Gt, bn, Ar, xr, Yt, wn, bt, yn, ue, En, N, Qe, Qt, j, Xe, Je, ee, Et, Zt, Jt, eo, to, oo, no, ro, z, Re, Y, te, Ne, Ae, Ze, io, Be, so, lo, Fe, et, ao, At, Dr, oe, xe, k, ot, uo, tt, co, fo, O, St, Lt, po, mo, It, ho, go, bo;
  var init_dist = __esm({
    "node_modules/@tailwindplus/elements/dist/index.js"() {
      Sn = Object.defineProperty;
      Eo = (e) => {
        throw TypeError(e);
      };
      Ln = (e, o, t) => o in e ? Sn(e, o, {enumerable: true, configurable: true, writable: true, value: t}) : e[o] = t;
      C = (e, o, t) => Ln(e, typeof o != "symbol" ? o + "" : o, t);
      kt = (e, o, t) => o.has(e) || Eo("Cannot " + t);
      f = (e, o, t) => (kt(e, o, "read from private field"), t ? t.call(e) : o.get(e));
      L = (e, o, t) => o.has(e) ? Eo("Cannot add the same private member more than once") : o instanceof WeakSet ? o.add(e) : o.set(e, t);
      I = (e, o, t, n) => (kt(e, o, "write to private field"), n ? n.call(e, t) : o.set(e, t), t);
      M = (e, o, t) => (kt(e, o, "access private method"), t);
      if (typeof globalThis.window < "u") {
        let e = false;
        document.addEventListener("submit", (o) => {
          if (e) {
            e = false;
            return;
          }
          let t = o.target;
          if (t && t.method === "dialog") {
            let n = t.closest("el-dialog");
            if (!n || !("beforeClose" in n))
              return;
            let r = n.beforeClose();
            if (r === true || (o.preventDefault(), o.stopImmediatePropagation(), r === false))
              return;
            r.then((i) => {
              i && (e = true, t.dispatchEvent(o));
            }).catch(console.error);
          }
        }, true);
      }
      lt = class extends Event {
        constructor(o, {oldState: t = "", newState: n = "", ...r} = {}) {
          super(o, r);
          C(this, "oldState");
          C(this, "newState");
          this.oldState = String(t || ""), this.newState = String(n || "");
        }
      };
      Ao = new WeakMap();
      Rt = globalThis.ShadowRoot || function() {
      };
      In = globalThis.HTMLDialogElement || function() {
      };
      nt = new WeakMap();
      Q = new WeakMap();
      F = new WeakMap();
      Se = new WeakMap();
      it = new WeakMap();
      st = new WeakMap();
      Ot = new WeakMap();
      Dt = new WeakMap();
      Po = globalThis.ShadowRoot || function() {
      };
      Rn = /(^|[^\\]):popover-open\b/g;
      Te = null;
      typeof globalThis.window < "u" && (Co() || (Mo(), at(async () => {
        if (await Fn("popover-polyfill"))
          return;
        let e = document.createElement("style");
        e.textContent = "@layer popover-polyfill;", e.setAttribute("suppressHydrationWarning", ""), e.addEventListener("securitypolicyviolation", () => {
          console.log("CSP rules on this website prevented @tailwindplus/elements from defining `popover-polyfill` as the first CSS layer. This is necessary to ensure the popover polyfill behaves correctly with CSS layers. To fix this, please manually add the following CSS to the top of your first stylesheet:\n\n```\n@layer popover-polyfill;\n```");
        }), document.documentElement.prepend(e);
      })), Ho() || Ro(), Bo() || No());
      ut = false;
      if (typeof globalThis.window < "u") {
        let e;
        ((n) => (n[n.Keyboard = 0] = "Keyboard", n[n.Mouse = 1] = "Mouse"))(e || (e = {})), document.addEventListener("keydown", (o) => {
          o.metaKey || o.altKey || o.ctrlKey || (ut = true, document.documentElement.dataset.focusVisible = "");
        }, true), document.addEventListener("click", (o) => {
          o.detail === 1 ? (ut = false, delete document.documentElement.dataset.focusVisible) : o.detail === 0 && (ut = true, document.documentElement.dataset.focusVisible = "");
        }, true);
      }
      typeof globalThis.HTMLElement > "u" && (globalThis.HTMLElement = class {
      });
      x = class extends HTMLElement {
        constructor() {
          super(...arguments);
          L(this, ge, new AbortController());
          L(this, $e, false);
          L(this, ie, false);
        }
        connectedCallback() {
          if ("observedAttributes" in this.constructor && typeof this.constructor.observedAttributes == "object" && Array.isArray(this.constructor.observedAttributes))
            for (let t of this.constructor.observedAttributes)
              typeof t == "string" && (t in this || Object.defineProperty(this, t, {get() {
                return this.getAttribute(t);
              }, set(n) {
                if (n == null || n === false) {
                  this.removeAttribute(t);
                  return;
                }
                this.setAttribute(t, n.toString());
              }}));
          I(this, $e, true), queueMicrotask(() => {
            if (!f(this, ge).signal.aborted)
              try {
                this.mount?.(f(this, ge).signal);
              } catch (t) {
                console.error(t);
              }
          });
        }
        disconnectedCallback() {
          f(this, ge).abort(), I(this, ge, new AbortController());
        }
        setAttributeNoCallbacks(t, n) {
          try {
            I(this, ie, true), this.setAttribute(t, n);
          } finally {
            I(this, ie, false);
          }
        }
        removeAttributeNoCallbacks(t) {
          try {
            I(this, ie, true), this.removeAttribute(t);
          } finally {
            I(this, ie, false);
          }
        }
        attributeChangedCallback(t, n, r) {
          f(this, $e) && (f(this, ie) || n !== r && this.onAttributeChange?.(t, n, r));
        }
      };
      ge = new WeakMap(), $e = new WeakMap(), ie = new WeakMap();
      Oe = Math.min;
      J = Math.max;
      Ke = Math.round;
      Ue = Math.floor;
      $ = (e) => ({x: e, y: e});
      _n = {left: "right", right: "left", bottom: "top", top: "bottom"};
      Kn = {start: "end", end: "start"};
      Un = new Set(["top", "bottom"]);
      Fo = ["left", "right"];
      qo = ["right", "left"];
      jn = ["top", "bottom"];
      zn = ["bottom", "top"];
      Uo = async (e, o, t) => {
        let {placement: n = "bottom", strategy: r = "absolute", middleware: i = [], platform: s} = t, a = i.filter(Boolean), l = await (s.isRTL == null ? void 0 : s.isRTL(o)), u = await s.getElementRects({reference: e, floating: o, strategy: r}), {x: p, y: c} = Ko(u, n, l), g = n, v = {}, d = 0;
        for (let m = 0; m < a.length; m++) {
          let {name: h, fn: w} = a[m], {x: y, y: b, data: A, reset: E} = await w({x: p, y: c, initialPlacement: n, placement: g, strategy: r, middlewareData: v, rects: u, platform: s, elements: {reference: e, floating: o}});
          p = y ?? p, c = b ?? c, v = {...v, [h]: {...v[h], ...A}}, E && d <= 50 && (d++, typeof E == "object" && (E.placement && (g = E.placement), E.rects && (u = E.rects === true ? await s.getElementRects({reference: e, floating: o, strategy: r}) : E.rects), {x: p, y: c} = Ko(u, g, l)), m = -1);
        }
        return {x: p, y: c, placement: g, strategy: r, middlewareData: v};
      };
      jo = function(e) {
        return e === void 0 && (e = {}), {name: "flip", options: e, async fn(o) {
          var t, n;
          let {placement: r, middlewareData: i, rects: s, initialPlacement: a, platform: l, elements: u} = o, {mainAxis: p = true, crossAxis: c = true, fallbackPlacements: g, fallbackStrategy: v = "bestFit", fallbackAxisSideDirection: d = "none", flipAlignment: m = true, ...h} = ft(e, o);
          if ((t = i.arrow) != null && t.alignmentOffset)
            return {};
          let w = be(r), y = se(a), b = be(a) === a, A = await (l.isRTL == null ? void 0 : l.isRTL(u.floating)), E = g || (b || !m ? [_e(a)] : Wo(a)), S = d !== "none";
          !g && S && E.push(...$o(a, m, d, A));
          let H = [a, ...E], ce = await Vt(o, h), D = [], ne = ((n = i.flip) == null ? void 0 : n.overflows) || [];
          if (p && D.push(ce[w]), c) {
            let fe = Vo(r, s, A);
            D.push(ce[fe[0]], ce[fe[1]]);
          }
          if (ne = [...ne, {placement: r, overflows: D}], !D.every((fe) => fe <= 0)) {
            var vo, wo;
            let fe = (((vo = i.flip) == null ? void 0 : vo.index) || 0) + 1, Pt = H[fe];
            if (Pt && (!(c === "alignment" ? y !== se(Pt) : false) || ne.every((W) => se(W.placement) === y ? W.overflows[0] > 0 : true)))
              return {data: {index: fe, overflows: ne}, reset: {placement: Pt}};
            let qe = (wo = ne.filter((de) => de.overflows[0] <= 0).sort((de, W) => de.overflows[1] - W.overflows[1])[0]) == null ? void 0 : wo.placement;
            if (!qe)
              switch (v) {
                case "bestFit": {
                  var yo;
                  let de = (yo = ne.filter((W) => {
                    if (S) {
                      let re = se(W.placement);
                      return re === y || re === "y";
                    }
                    return true;
                  }).map((W) => [W.placement, W.overflows.filter((re) => re > 0).reduce((re, Tn) => re + Tn, 0)]).sort((W, re) => W[1] - re[1])[0]) == null ? void 0 : yo[0];
                  de && (qe = de);
                  break;
                }
                case "initialPlacement":
                  qe = a;
                  break;
              }
            if (r !== qe)
              return {reset: {placement: qe}};
          }
          return {};
        }};
      };
      zo = function(e) {
        return e === void 0 && (e = {}), {name: "shift", options: e, async fn(o) {
          let {x: t, y: n, placement: r} = o, {mainAxis: i = true, crossAxis: s = false, limiter: a = {fn: (h) => {
            let {x: w, y} = h;
            return {x: w, y};
          }}, ...l} = ft(e, o), u = {x: t, y: n}, p = await Vt(o, l), c = se(be(r)), g = Nt(c), v = u[g], d = u[c];
          if (i) {
            let h = g === "y" ? "top" : "left", w = g === "y" ? "bottom" : "right", y = v + p[h], b = v - p[w];
            v = Bt(y, v, b);
          }
          if (s) {
            let h = c === "y" ? "top" : "left", w = c === "y" ? "bottom" : "right", y = d + p[h], b = d - p[w];
            d = Bt(y, d, b);
          }
          let m = a.fn({...o, [g]: v, [c]: d});
          return {...m, data: {x: m.x - t, y: m.y - n, enabled: {[g]: i, [c]: s}}};
        }};
      };
      Qn = new Set(["inline", "contents"]);
      Xn = new Set(["table", "td", "th"]);
      Jn = [":popover-open", ":modal"];
      Zn = ["transform", "translate", "scale", "rotate", "perspective"];
      er = ["transform", "translate", "scale", "rotate", "perspective", "filter"];
      tr = ["paint", "layout", "strict", "content"];
      or = new Set(["html", "body", "#document"]);
      nr = $(0);
      ur = new Set(["absolute", "fixed"]);
      hr = async function(e) {
        let o = this.getOffsetParent || sn, t = this.getDimensions, n = await t(e.floating);
        return {reference: mr(e.reference, await o(e.floating), e.strategy), floating: {x: 0, y: 0, width: n.width, height: n.height}};
      };
      Kt = {convertOffsetParentRelativeRectToViewportRelativeRect: ir, getDocumentElement: _, getClippingRect: dr, getOffsetParent: sn, getElementRects: hr, getClientRects: sr, getDimensions: pr, getScale: Me, isElement: q, isRTL: gr};
      un = zo;
      cn = jo;
      fn = (e, o, t) => {
        let n = new Map(), r = {platform: Kt, ...t}, i = {...r.platform, _c: n};
        return Uo(e, o, {...r, platform: i});
      };
      gn = {get selectRequired() {
        let e = document.createElement("select");
        e.setAttribute("required", "true");
        let o = e.validationMessage;
        return Object.defineProperty(this, "selectRequired", {value: o}), o;
      }};
      Ye = false;
      zt = false;
      typeof navigator < "u" && (Ye = /^((?!chrome|android).)*safari/i.test(navigator.userAgent), zt = navigator.userAgent.toLowerCase().includes("firefox"));
      Gt = false;
      bn = new WeakSet();
      Ar = 0;
      xr = 200;
      Yt = null;
      wn = false;
      bt = class extends Map {
        constructor(t) {
          super();
          this.factory = t;
        }
        get(t) {
          let n = super.get(t);
          return n === void 0 && (n = this.factory(t, this), this.set(t, n)), n;
        }
      };
      yn = new bt(() => ({referenceCounter: 0, d: X()}));
      ue = ["[contentEditable=true]", "[tabindex]", "a[href]", "area[href]", "button:not([disabled])", "iframe", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].map((e) => `${e}:not([tabindex='-1'])`).join(",");
      En = /([\u2700-\u27BF]|[\uE000-\uF8FF]|\uD83C[\uDC00-\uDFFF]|\uD83D[\uDC00-\uDFFF]|[\u2011-\u26FF]|\uD83E[\uDD10-\uDDFF])/g;
      Qt = class extends x {
        constructor() {
          super(...arguments);
          L(this, N, []);
          L(this, Qe, null);
        }
        mount(t) {
          let n = this.getInput(), r = this.getButton(), i = this.getOptions();
          n.id || (n.id = P("autocomplete-input")), r && (r.id || (r.id = P("autocomplete-button"))), i.id || (i.id = P("autocomplete-listbox")), He(i, () => this.getButton(), () => this.getInput(), t, () => this.onBeforeOpen(), () => this.onBeforeClose()), wt(i, t), n.setAttribute("role", "combobox"), n.setAttribute("aria-autocomplete", "list"), n.setAttribute("aria-expanded", "false"), n.setAttribute("aria-controls", i.id), n.setAttribute("aria-activedescendant", ""), n.setAttribute("autocomplete", "off"), r && (r.setAttribute("type", "button"), r.setAttribute("tabindex", "-1"), r.setAttribute("aria-expanded", "false"), r.setAttribute("aria-haspopup", "listbox"), r.setAttribute("popovertarget", i.id)), i.setAttribute("role", "listbox"), i.setAttribute("popover", "manual");
          let s = this;
          function a() {
            for (let c of i.getItems())
              c.getAttribute("role") !== "option" && (c.id || (c.id = P("option")), c.setAttribute("role", "option"), c.setAttribute("aria-selected", "false"), c.setAttribute("tabIndex", "-1"), c.addEventListener("mousedown", (g) => {
                g.button === 0 && (g.preventDefault(), s.selectOption(c));
              }, {signal: t}), ae(c, "mouseover", t, () => s.setActiveItem(c, false)), ae(c, "mouseout", t, () => s.clearActiveItem()));
            s.filterOptions();
          }
          a();
          let l = new MutationObserver(a);
          l.observe(this, {attributes: false, childList: true, subtree: true}), r && U(r, "--button-width", t, this), U(n, "--input-width", t, this), n.addEventListener("input", () => {
            n.matches(":disabled") || (this.filterOptions(), f(this, N).length > 0 ? i.hasAttribute("open") || i.showPopover() : i.hidePopover());
          }, {signal: t});
          let u = () => {
            n.matches(":disabled") || (n.focus(), i.hasAttribute("open") ? i.hidePopover() : (this.filterOptions(), f(this, N).length > 0 && i.showPopover()));
          };
          n.addEventListener("pointerdown", u, {signal: t}), r && (r.addEventListener("pointerdown", (c) => {
            c.preventDefault(), u();
          }, {signal: t}), r.addEventListener("click", (c) => {
            c.preventDefault(), c.stopImmediatePropagation();
          }, {signal: t})), n.addEventListener("blur", ({relatedTarget: c}) => {
            c && this.contains(c) || i.hidePopover();
          }, {signal: t}), n.addEventListener("keydown", (c) => {
            if (!n.matches(":disabled"))
              switch (c.key) {
                case "ArrowDown": {
                  c.preventDefault(), i.hasAttribute("open") || (f(this, N).length === 0 && this.filterOptions(), f(this, N).length > 0 && i.showPopover()), this.goToItem(3);
                  break;
                }
                case "ArrowUp": {
                  c.preventDefault(), i.hasAttribute("open") || (f(this, N).length === 0 && this.filterOptions(), f(this, N).length > 0 && i.showPopover()), this.goToItem(2);
                  break;
                }
                case "Home":
                case "PageUp":
                  return i.hasAttribute("open") ? (c.preventDefault(), c.stopPropagation(), this.goToItem(0)) : void 0;
                case "End":
                case "PageDown":
                  return i.hasAttribute("open") ? (c.preventDefault(), c.stopPropagation(), this.goToItem(1)) : void 0;
                case "Enter": {
                  let g = this.getActiveItem();
                  g && (c.preventDefault(), this.selectOption(g)), i.hasAttribute("open") && (c.preventDefault(), i.hidePopover());
                  break;
                }
                case "Escape": {
                  if (!i.hasAttribute("open"))
                    return;
                  c.preventDefault(), i.hidePopover();
                  break;
                }
                case "Tab": {
                  i.hidePopover();
                  break;
                }
              }
          }, {signal: t});
          let p = Array.from(i.querySelectorAll("el-option[disabled]"));
          for (let c of p)
            c.setAttribute("aria-disabled", "true"), c.setAttribute("aria-selected", "false");
          t.addEventListener("abort", () => {
            l.disconnect();
          });
        }
        getInput() {
          let t = this.querySelector("input");
          if (!t)
            throw new Error("`<el-autocomplete>` must contain an input element.");
          return t;
        }
        getButton() {
          return this.querySelector("button");
        }
        getOptions() {
          let t = this.querySelector("el-options");
          if (!t)
            throw new Error("`<el-autocomplete>` must contain a `<el-options>` element.");
          return t;
        }
        filterOptions() {
          let t = this.getInput().value.toLowerCase();
          f(this, Qe) !== t && (this.clearActiveItem(), I(this, Qe, t)), I(this, N, []);
          for (let n of this.getOptions().getItems()) {
            let r = n.getAttribute("value")?.toLowerCase() || "", i = yt(n)?.trim().toLowerCase() ?? "";
            t === "" || r.includes(t) || i.includes(t) ? (f(this, N).push(n), n.removeAttribute("hidden"), n.removeAttribute("aria-hidden")) : (n.setAttribute("hidden", ""), n.setAttribute("aria-hidden", "true"));
          }
        }
        getActiveItem() {
          let n = this.getInput().getAttribute("aria-activedescendant");
          return n ? document.getElementById(n) : null;
        }
        goToItem(t) {
          if (f(this, N).length === 0)
            return;
          let n = this.getActiveItem(), r = G(f(this, N), n, t);
          r && this.setActiveItem(r);
        }
        setActiveItem(t, n = true) {
          let r = this.getInput(), i = this.getActiveItem();
          i !== null && i.setAttribute("aria-selected", "false"), t.setAttribute("aria-selected", "true"), r.setAttribute("aria-activedescendant", t.id), n && t.scrollIntoView({block: "nearest"});
        }
        clearActiveItem() {
          let t = this.getInput(), n = this.getActiveItem();
          n !== null && n.setAttribute("aria-selected", "false"), t.setAttribute("aria-activedescendant", "");
        }
        selectOption(t) {
          let n = this.getInput(), r = t.getAttribute("value");
          r && (n.value = r, n.dispatchEvent(new Event("input", {bubbles: true, cancelable: true})), n.dispatchEvent(new Event("change", {bubbles: true, cancelable: true})), this.getOptions().hidePopover());
        }
        onBeforeOpen() {
          let t = this.getInput(), n = this.getButton();
          t.setAttribute("aria-expanded", "true"), n?.setAttribute("aria-expanded", "true");
        }
        onBeforeClose() {
          let t = this.getInput(), n = this.getButton();
          t.setAttribute("aria-expanded", "false"), n?.setAttribute("aria-expanded", "false"), this.clearActiveItem();
        }
      };
      N = new WeakMap(), Qe = new WeakMap();
      T("el-autocomplete", Qt);
      Jt = class extends x {
        constructor() {
          super(...arguments);
          L(this, ee);
          L(this, j, []);
          L(this, Xe, null);
          L(this, Je, ({query: t, content: n}) => n.toLocaleLowerCase().includes(t.toLocaleLowerCase().trim()));
        }
        mount(t) {
          let n = this.getInput(), r = this.getItems();
          n.id || (n.id = P("command-input")), r.id || (r.id = P("command-items")), n.setAttribute("role", "combobox"), n.setAttribute("aria-autocomplete", "list"), n.setAttribute("autocomplete", "off"), n.setAttribute("aria-controls", r.id), r.setAttribute("role", "listbox");
          let i = this;
          function s(l = false) {
            var u;
            for (let p of r.getItems())
              p.getAttribute("role") !== "option" && (p.id || (p.id = P("item")), p.setAttribute("role", "option"), p.setAttribute("tabIndex", "-1"), p.setAttribute("aria-selected", "false"), p.hasAttribute("disabled") && p.setAttribute("aria-disabled", "true"), ae(p, "mouseover", t, () => {
                var c;
                return M(c = i, ee, Zt).call(c, p, false);
              }));
            M(u = i, ee, Et).call(u, l), l || i.goToItem(0);
          }
          s(true);
          let a = new MutationObserver(() => s(false));
          a.observe(this, {attributes: false, childList: true, subtree: true}), U(n, "--input-width", t, this), n.addEventListener("input", () => M(this, ee, Et).call(this), {signal: t}), n.addEventListener("keydown", (l) => {
            switch (l.key) {
              case "ArrowDown": {
                l.preventDefault(), this.goToItem(3);
                break;
              }
              case "ArrowUp": {
                l.preventDefault(), this.goToItem(2);
                break;
              }
              case "Home":
              case "PageUp":
                return l.preventDefault(), l.stopPropagation(), this.goToItem(0);
              case "End":
              case "PageDown":
                return l.preventDefault(), l.stopPropagation(), this.goToItem(1);
              case "Enter": {
                let u = this.getActiveItem();
                u && (l.preventDefault(), u.click());
                break;
              }
              case "Tab":
                break;
            }
          }, {signal: t}), t.addEventListener("abort", () => {
            a.disconnect();
          });
        }
        getInput() {
          let t = this.querySelector("input");
          if (!t)
            throw new Error("`<el-command-palette>` must contain an input element.");
          return t;
        }
        getItems() {
          let t = this.querySelector("el-command-list");
          if (!t)
            throw new Error("`<el-command-palette>` must contain a `<el-command-list>` element.");
          return t;
        }
        getGroups() {
          return this.getItems().querySelectorAll("el-command-group");
        }
        getSuggestions() {
          return this.querySelector("el-defaults");
        }
        getActiveItem() {
          let n = this.getInput().getAttribute("aria-activedescendant");
          return n ? document.getElementById(n) : null;
        }
        goToItem(t) {
          if (f(this, j).length === 0)
            return;
          let n = this.getActiveItem(), r = G(f(this, j), n, t);
          r && M(this, ee, Zt).call(this, r);
        }
        clearActiveItem() {
          let t = this.getInput(), n = this.getActiveItem();
          if (n !== null) {
            n.setAttribute("aria-selected", "false");
            let r = this.querySelector(`el-command-preview[for="${n.id}"]`);
            r && r.setAttribute("hidden", "");
          }
          t.removeAttribute("aria-activedescendant"), this.dispatchEvent(new CustomEvent("change", {detail: {relatedTarget: null}, bubbles: false, cancelable: false}));
        }
        reset() {
          let t = this.getInput();
          t.value = "", t.dispatchEvent(new Event("input", {bubbles: true, cancelable: true})), t.dispatchEvent(new Event("change", {bubbles: true, cancelable: true})), M(this, ee, Et).call(this, true), this.clearActiveItem();
        }
        setFilterCallback(t) {
          I(this, Je, t);
        }
      };
      j = new WeakMap(), Xe = new WeakMap(), Je = new WeakMap(), ee = new WeakSet(), Et = function(t = false) {
        let n = this.getItems(), r = this.getInput().value ?? "";
        I(this, j, []);
        for (let a of n.getItems()) {
          if (a.closest("el-defaults"))
            continue;
          let l = An(a) ?? "";
          r === "" || !f(this, Je).call(this, {query: r, node: a, content: l}) ? (a.setAttribute("hidden", ""), a.setAttribute("aria-hidden", "true")) : (f(this, j).push(a), a.removeAttribute("hidden"), a.removeAttribute("aria-hidden"));
        }
        for (let a of this.getGroups())
          a.getItems().some((u) => !u.hasAttribute("hidden")) ? a.removeAttribute("hidden") : a.setAttribute("hidden", "");
        let i = this.getSuggestions();
        i && (r === "" ? (i.removeAttribute("hidden"), I(this, j, i.getItems())) : i.setAttribute("hidden", ""));
        let s = this.querySelector("el-no-results");
        s && (r === "" || f(this, j).length > 0 ? s.setAttribute("hidden", "") : s.removeAttribute("hidden")), f(this, j).length === 0 ? n.setAttribute("hidden", "") : n.removeAttribute("hidden"), !(t && r === "") && (f(this, j).length === 0 ? this.clearActiveItem() : f(this, Xe) !== r && this.goToItem(0), I(this, Xe, r));
      }, Zt = function(t, n = true) {
        let r = this.getInput(), i = this.getActiveItem();
        if (t === i)
          return;
        if (i !== null) {
          i.setAttribute("aria-selected", "false");
          let a = this.querySelector(`el-command-preview[for="${i.id}"]`);
          a && a.setAttribute("hidden", "");
        }
        t.setAttribute("aria-selected", "true"), r.setAttribute("aria-activedescendant", t.id);
        let s = this.querySelector(`el-command-preview[for="${t.id}"]`);
        s && s.removeAttribute("hidden"), n && t.scrollIntoView({block: "nearest"}), this.dispatchEvent(new CustomEvent("change", {detail: {relatedTarget: t}, bubbles: false, cancelable: false}));
      };
      eo = class extends x {
        getItems() {
          return Array.from(this.querySelectorAll(`${ue},[role="option"]`));
        }
      };
      to = class extends x {
        getItems() {
          return Array.from(this.querySelectorAll(`${ue},[role="option"]`));
        }
      };
      oo = class extends x {
      };
      no = class extends x {
      };
      ro = class extends x {
        getItems() {
          return Array.from(this.querySelectorAll(`${ue},[role="option"]`));
        }
      };
      T("el-command-palette", Jt);
      T("el-command-list", eo);
      T("el-defaults", to);
      T("el-no-results", oo);
      T("el-command-group", ro);
      T("el-command-preview", no);
      z = [];
      at(() => {
        function e(o) {
          if (o.target === document.body || z[0] === o.target)
            return;
          let t = o.target;
          t && "closest" in t && (t = t.closest(ue), z.unshift(t ?? o.target), z = z.filter((n) => n != null && n.isConnected), z.splice(10));
        }
        window.addEventListener("click", e, {capture: true}), window.addEventListener("pointerdown", e, {capture: true}), window.addEventListener("focus", e, {capture: true}), document.body.addEventListener("click", e, {capture: true}), document.body.addEventListener("pointerdown", e, {capture: true}), document.body.addEventListener("focus", e, {capture: true});
      });
      Re = null;
      typeof globalThis.window < "u" && (Re = HTMLDialogElement.prototype.close, Object.defineProperties(HTMLDialogElement.prototype, {close: {value() {
        let e = this.closest("el-dialog");
        if (!(e instanceof Be))
          return Re?.apply(this, arguments);
        let o = e.beforeClose();
        if (o === true)
          return Re?.apply(this, arguments);
        o !== false && o.then((t) => t ? Re?.apply(this, arguments) : null).catch(console.error);
      }}}), document.addEventListener("command", (e) => {
        let o = e.target;
        if (!(o instanceof HTMLDialogElement) || !("command" in e) || e.command !== "close")
          return;
        let t = o.closest("el-dialog");
        if (!(t instanceof Be))
          return;
        let n = t.beforeClose();
        n !== true && (e.stopImmediatePropagation(), e.preventDefault(), n !== false && n.then((r) => r ? Re?.apply(o) : null).catch(console.error));
      }, true));
      Be = class extends x {
        constructor() {
          super(...arguments);
          L(this, Ze);
          L(this, Y, null);
          L(this, te, null);
          L(this, Ne, true);
          L(this, Ae, ke(this, () => Array.from(this.querySelectorAll("el-dialog-panel,el-dialog-backdrop"))));
        }
        mount(t) {
          let n = this.getNativeDialog();
          n.removeAttribute("open"), n.style.setProperty("right", "var(--el-top-layer-scrollbar-offset, 0px)");
          let r = this.hasAttribute("open");
          for (let a of M(this, Ze, io).call(this))
            a.setAttribute("aria-expanded", r.toString());
          Or(n, t, (a) => {
            a.preventDefault();
            let l = new Event("cancel", {bubbles: false, cancelable: true});
            !this.dispatchEvent(l) || n.close();
          });
          let i = this.querySelector("el-dialog-panel");
          le(i ?? n, t, () => {
            this.hasAttribute("open") && n.close();
          });
          let s = null;
          n.addEventListener("beforetoggle", (a) => {
            let l = a;
            l.newState === "open" && l.oldState === "closed" && this.beforeOpen();
            let u = this.hasAttribute("open");
            if (l.newState === "open" && !u ? (this.dispatchEvent(new CustomEvent("open", {bubbles: false, cancelable: false})), this.setAttribute("open", "")) : l.newState === "closed" && u && (this.dispatchEvent(new CustomEvent("close", {bubbles: false, cancelable: false})), this.removeAttribute("open")), l.newState === "open" && l.oldState === "closed")
              z.length > 0 && !s && (s = z[0]);
            else if (l.newState === "closed" && l.oldState === "open") {
              let p = f(this, Ne);
              setTimeout(() => {
                if (!p) {
                  s && s === document.activeElement && s.isConnected && "blur" in s && typeof s.blur == "function" && s.blur();
                  return;
                }
                s && s !== document.activeElement && s.isConnected && Pe(s), s = null;
              });
            }
          }, {signal: t}), t.addEventListener("abort", () => {
            var a;
            f(this, Ae).abort(), (a = f(this, te)) == null || a.call(this);
          }), this.hasAttribute("open") && n.showModal();
        }
        onAttributeChange(t, n, r) {
          switch (t) {
            case "open": {
              let i = this.getNativeDialog();
              for (let s of M(this, Ze, io).call(this))
                s.setAttribute("aria-expanded", r !== null ? "true" : "false");
              r === null ? i.close() : i.showModal();
              break;
            }
          }
        }
        getNativeDialog() {
          let t = this.querySelector("dialog");
          if (!t)
            throw new Error("[ElDialog] No `<dialog>` element found");
          return t;
        }
        beforeOpen() {
          I(this, Ne, true), f(this, Y) && (f(this, Y).abort(), I(this, Y, null)), f(this, te) || I(this, te, vt(this.ownerDocument)), f(this, Ae) && f(this, Ae).start("in");
        }
        beforeClose() {
          if (f(this, te) && (f(this, te).call(this), I(this, te, null)), f(this, Y))
            return false;
          I(this, Y, new AbortController());
          let t = f(this, Y).signal;
          return new Promise((n) => {
            f(this, Ae)?.start("out", () => {
              t.aborted || (I(this, Y, null), requestAnimationFrame(() => {
                let r = this.getNativeDialog(), i = r.style.cssText;
                r.style.cssText = i + "transition-duration: 0 !important;", Re?.apply(r), requestAnimationFrame(() => {
                  r.style.cssText = i;
                });
              }), n(true));
            });
          });
        }
        show() {
          this.getNativeDialog().showModal();
        }
        hide({restoreFocus: t = true} = {}) {
          I(this, Ne, t), this.getNativeDialog().close();
        }
      };
      Y = new WeakMap(), te = new WeakMap(), Ne = new WeakMap(), Ae = new WeakMap(), Ze = new WeakSet(), io = function() {
        return document.querySelectorAll(`[commandfor="${this.getNativeDialog().id}"]`);
      }, C(Be, "observedAttributes", ["open"]);
      so = class extends x {
        mount(o) {
          kr(this, o, () => {
            let t = this.getDialog(), n = t.getNativeDialog();
            if (!n.hasAttribute("open"))
              return;
            let r = new Event("cancel", {bubbles: false, cancelable: true});
            !t.dispatchEvent(r) || n.close();
          });
        }
        getDialog() {
          let o = this.closest("el-dialog");
          if (!o)
            throw new Error("[ElDialogPanel] No `<el-dialog>` parent found");
          return o;
        }
      };
      lo = class extends x {
        mount() {
          this.setAttribute("inert", "");
        }
      };
      T("el-dialog", Be);
      T("el-dialog-panel", so);
      T("el-dialog-backdrop", lo);
      At = class extends x {
        constructor() {
          super(...arguments);
          L(this, et);
          L(this, Fe, ke(this));
        }
        mount(t) {
          this.id || (this.id = P("disclosure")), this.hasAttribute("hidden") ? this.removeAttributeNoCallbacks("open") : this.setAttributeNoCallbacks("open", "");
          let n = () => {
            this.hasAttribute("open") && this.hide();
          }, r = !this.hasAttribute("hidden");
          for (let i of M(this, et, ao).call(this))
            le(i, t, n), i.setAttribute("aria-expanded", r.toString()), i.setAttribute("aria-controls", this.id);
          this.addEventListener("command", (i) => {
            if (i.target instanceof HTMLElement && "command" in i)
              switch (i.command) {
                case "--show": {
                  this.show(), i.preventDefault();
                  break;
                }
                case "--hide": {
                  this.hide(), i.preventDefault();
                  break;
                }
                case "--toggle": {
                  this.toggle(), i.preventDefault();
                  break;
                }
              }
          }, {signal: t}), le(this, t, n), t.addEventListener("abort", () => f(this, Fe).abort());
        }
        onAttributeChange(t, n, r) {
          switch (t) {
            case "hidden": {
              r === null ? this.setAttributeNoCallbacks("open", "") : this.removeAttributeNoCallbacks("open");
              for (let i of M(this, et, ao).call(this))
                i.setAttribute("aria-expanded", r === null ? "true" : "false");
              r === null ? f(this, Fe).start("in") : f(this, Fe).start("out");
              break;
            }
            case "open": {
              r === null ? this.hide() : this.show();
              break;
            }
          }
        }
        show() {
          this.removeAttribute("hidden");
        }
        hide() {
          this.setAttribute("hidden", "");
        }
        toggle() {
          this.hasAttribute("hidden") ? this.show() : this.hide();
        }
      };
      Fe = new WeakMap(), et = new WeakSet(), ao = function() {
        return document.querySelectorAll(`[commandfor="${this.id}"]`);
      }, C(At, "observedAttributes", ["hidden", "open"]);
      T("el-disclosure", At);
      Dr = 200;
      tt = class extends x {
        constructor() {
          super(...arguments);
          L(this, ot);
          L(this, oe, this.attachInternals());
          L(this, xe, "");
          L(this, k, null);
        }
        mount(t) {
          let n = this.getOptions();
          this.value = this.getAttribute("value") ?? this.value ?? "";
          let r = this.getButton();
          r.id || (r.id = P("select-button")), U(r, "--button-width", t, this), r.addEventListener("keydown", (s) => {
            if (!r.matches(":disabled"))
              switch (s.key) {
                case "ArrowUp": {
                  n.showPopover(), this.goToItem("selected"), s.preventDefault();
                  break;
                }
                case "ArrowDown": {
                  n.showPopover(), this.goToItem("selected"), s.preventDefault();
                  break;
                }
                case "Enter": {
                  s.preventDefault(), f(this, oe).form && f(this, oe).form.requestSubmit();
                  break;
                }
                case " ": {
                  if (n.hasAttribute("open") && f(this, k) && f(this, k).hasActiveSearchQuery()) {
                    s.preventDefault(), s.stopPropagation(), f(this, k).handleSearchKey(s.key);
                    break;
                  }
                  s.preventDefault(), n.hasAttribute("open") ? n.hidePopover() : (n.showPopover(), this.goToItem("selected"));
                  break;
                }
                default: {
                  n.hasAttribute("open") && s.key.length === 1 && !s.ctrlKey && !s.altKey && !s.metaKey && (s.preventDefault(), s.stopPropagation(), this.handleSearchKey(s.key));
                  break;
                }
              }
          }, {signal: t});
          for (let s of f(this, oe).labels)
            s.setAttribute("for", r.id);
          I(this, k, Tt(n, {role: "listbox", getItems: () => this.getItems(), onItemClick: (s) => this.setSelectedOption(s), getButton: () => this.getButton(), onBeforeOpen: () => this.onBeforeOpen(), onBeforeClose: () => this.onBeforeClose()}, t)), n.addEventListener("keydown", (s) => {
            switch (s.key) {
              case "ArrowDown":
                return s.preventDefault(), s.stopPropagation(), this.goToItem(3);
              case "ArrowUp":
                return s.preventDefault(), s.stopPropagation(), this.goToItem(2);
              case "Home":
              case "PageUp":
                return s.preventDefault(), s.stopPropagation(), this.goToItem(0);
              case "End":
              case "PageDown":
                return s.preventDefault(), s.stopPropagation(), this.goToItem(1);
              case " ":
                if (f(this, k) && f(this, k).hasActiveSearchQuery()) {
                  s.preventDefault(), s.stopPropagation(), f(this, k).handleSearchKey(s.key);
                  return;
                }
              case "Enter": {
                s.preventDefault(), s.stopPropagation();
                let a = this.getActiveItem();
                a ? a.click() : n.hidePopover();
                return;
              }
              case "Tab": {
                f(this, k) && f(this, k).ignoreNextFocusRestoration();
                break;
              }
              case "Escape": {
                s.preventDefault(), s.stopPropagation(), n.hidePopover(), r.focus();
                break;
              }
              default: {
                s.key.length === 1 && !s.ctrlKey && !s.altKey && !s.metaKey && (s.preventDefault(), s.stopPropagation(), f(this, k) && f(this, k).handleSearchKey(s.key));
                break;
              }
            }
          }, {signal: t}), n.addEventListener("toggle", (s) => {
            s.newState === "open" && this.onOpen();
          }, {signal: t});
          let i = Array.from(n.querySelectorAll("el-option[disabled]"));
          for (let s of i)
            s.setAttribute("aria-disabled", "true"), s.setAttribute("aria-selected", "false");
        }
        onAttributeChange(t, n, r) {
          switch (t) {
            case "value": {
              r !== null && (this.value = r);
              break;
            }
            case "required": {
              M(this, ot, uo).call(this);
              break;
            }
          }
        }
        getButton() {
          let t = this.querySelector("button");
          if (!t)
            throw new Error("`<el-select>` must contain a button element.");
          return t;
        }
        getOptions() {
          let t = this.querySelector("el-options");
          if (!t)
            throw new Error("`<el-select>` must contain a `<el-options>` element.");
          return t;
        }
        setSelectedOption(t) {
          this.value = t.getAttribute("value"), this.dispatchEvent(new Event("input", {bubbles: true, cancelable: true})), this.dispatchEvent(new Event("change", {bubbles: true, cancelable: true})), this.getOptions().hidePopover();
        }
        getOptionByName(t) {
          return this.getOptions().getOptionByName(t);
        }
        getItems() {
          return this.getOptions().getItems();
        }
        getActiveItem() {
          return f(this, k)?.getActiveItem();
        }
        getSelectedOption() {
          return this.getOptionByName(f(this, xe));
        }
        goToItem(t = 4) {
          let n = this.getItems();
          if (n.length === 0)
            return;
          let r = this.getActiveItem();
          if (r === null && (t === 2 || t === 3)) {
            this.goToItem("selected");
            return;
          }
          if (t === "selected") {
            let s = this.getSelectedOption();
            s && B(s) ? this.setActiveItem(s) : this.goToItem(0);
            return;
          }
          let i = G(n, r, t);
          i && this.setActiveItem(i);
        }
        setActiveItem(t) {
          f(this, k) && f(this, k).setActiveItem(t);
        }
        clearActiveItem() {
          f(this, k) && f(this, k).clearActiveItem();
        }
        onBeforeOpen() {
          let t = this.getButton(), n = t.dataset.originalTabIndex;
          n && (t.dataset.originalTabIndex = n), t.setAttribute("tabIndex", "-1");
        }
        onOpen() {
          this.getActiveItem() === null && this.goToItem("selected");
        }
        onBeforeClose() {
          let t = this.getButton(), n = t.dataset.originalTabIndex;
          delete t.dataset.originalTabIndex, n !== void 0 ? t.setAttribute("tabIndex", n) : t.removeAttribute("tabIndex");
          let r = this.getActiveItem();
          r !== null && r.setAttribute("tabIndex", "-1");
        }
        handleSearchKey(t) {
          f(this, k) && f(this, k).handleSearchKey(t);
        }
        set value(t) {
          I(this, xe, t), f(this, oe).setFormValue(t), M(this, ot, uo).call(this);
          let n = this.getSelectedOption();
          if (n) {
            for (let r of this.getItems())
              r.setAttribute("aria-selected", "false");
            n.setAttribute("aria-selected", "true");
            try {
              this.querySelectorAll("el-selectedcontent").forEach((r) => r.update());
            } catch {
            }
          }
        }
        get value() {
          return f(this, xe);
        }
      };
      oe = new WeakMap(), xe = new WeakMap(), k = new WeakMap(), ot = new WeakSet(), uo = function() {
        if (!this.hasAttribute("required") || f(this, xe)) {
          f(this, oe).setValidity({});
          return;
        }
        f(this, oe).setValidity({valueMissing: true}, gn.selectRequired, this.getButton());
      }, C(tt, "formAssociated", true), C(tt, "observedAttributes", ["required"]);
      co = class extends x {
        mount() {
          this.update();
        }
        update() {
          let t = this.getSelect().getSelectedOption();
          if (!t)
            return;
          let n = document.createDocumentFragment();
          for (let r of t.childNodes)
            n.append(r.cloneNode(true));
          this.replaceChildren(n);
        }
        getSelect() {
          let o = this.closest("el-select");
          if (!o)
            throw new Error("`<el-selectedcontent>` must be inside of a `<el-select>` element.");
          return o;
        }
      };
      T("el-select", tt);
      T("el-selectedcontent", co);
      fo = class extends x {
        getButton() {
          let o = this.querySelector("button");
          if (!o)
            throw new Error("[ElDropdown] No `<button>` element found");
          return o;
        }
        mount(o) {
          let t = this.getButton();
          t.id || (t.id = P("dropdown-button")), U(t, "--button-width", o, this);
          let n = this.querySelectorAll("label");
          for (let r of n)
            r.setAttribute("for", t.id);
        }
      };
      St = class extends x {
        constructor() {
          super(...arguments);
          L(this, O, null);
        }
        mount(t) {
          I(this, O, Tt(this, {role: "menu", getItems: () => this.getItems(), onItemClick: () => this.hidePopover(), getButton: () => this.getDropdown().getButton(), onBeforeOpen: () => this.onBeforeOpen(), onBeforeClose: () => this.onBeforeClose()}, t));
          let r = this.getDropdown().getButton();
          r.addEventListener("keydown", (i) => {
            if (!r.disabled)
              switch (i.key) {
                case "ArrowDown": {
                  this.showPopover(), this.goToItem(0), i.preventDefault();
                  break;
                }
                case "ArrowUp": {
                  this.showPopover(), this.goToItem(1), i.preventDefault();
                  break;
                }
                case " ":
                  if (this.hasAttribute("open") && f(this, O) && f(this, O).hasActiveSearchQuery()) {
                    i.preventDefault(), i.stopPropagation(), f(this, O).handleSearchKey(i.key);
                    break;
                  }
                case "Enter": {
                  i.preventDefault(), this.hasAttribute("open") ? this.hidePopover() : (this.showPopover(), this.goToItem(0));
                  break;
                }
                default: {
                  this.hasAttribute("open") && i.key.length === 1 && !i.ctrlKey && !i.altKey && !i.metaKey && (i.preventDefault(), i.stopPropagation(), f(this, O) && f(this, O).handleSearchKey(i.key));
                  break;
                }
              }
          }, {signal: t}), this.addEventListener("keydown", (i) => {
            switch (i.key) {
              case "ArrowDown":
                return i.preventDefault(), i.stopPropagation(), this.goToItem(3);
              case "ArrowUp":
                return i.preventDefault(), i.stopPropagation(), this.goToItem(2);
              case "Home":
              case "PageUp":
                return i.preventDefault(), i.stopPropagation(), this.goToItem(0);
              case "End":
              case "PageDown":
                return i.preventDefault(), i.stopPropagation(), this.goToItem(1);
              case " ":
                if (f(this, O) && f(this, O).hasActiveSearchQuery()) {
                  i.preventDefault(), i.stopPropagation(), f(this, O).handleSearchKey(i.key);
                  return;
                }
              case "Enter": {
                i.preventDefault(), i.stopPropagation();
                let s = this.getActiveItem();
                s ? s.click() : this.hidePopover();
                return;
              }
              case "Tab": {
                f(this, O) && f(this, O).ignoreNextFocusRestoration();
                break;
              }
              case "Escape": {
                i.preventDefault(), i.stopPropagation(), this.hidePopover(), r.focus();
                break;
              }
              default: {
                i.key.length === 1 && !i.ctrlKey && !i.altKey && !i.metaKey && (i.preventDefault(), i.stopPropagation(), f(this, O) && f(this, O).handleSearchKey(i.key));
                break;
              }
            }
          }, {signal: t});
        }
        onBeforeOpen() {
          let n = this.getDropdown().getButton(), r = n.dataset.originalTabIndex;
          r && (n.dataset.originalTabIndex = r), n.setAttribute("tabIndex", "-1"), this.getActiveItem() === null && (this.setAttribute("tabIndex", "0"), setTimeout(() => this.focus({preventScroll: true})));
        }
        onBeforeClose() {
          let n = this.getDropdown().getButton(), r = n.dataset.originalTabIndex;
          delete n.dataset.originalTabIndex, r !== void 0 ? n.setAttribute("tabIndex", r) : n.removeAttribute("tabIndex");
          let i = this.getActiveItem();
          i !== null && i.setAttribute("tabIndex", "-1");
        }
        goToItem(t = 4) {
          let n = this.getItems();
          if (n.length === 0)
            return;
          let r = this.getActiveItem(), i = G(n, r, t);
          i && this.setActiveItem(i);
        }
        setActiveItem(t) {
          f(this, O) && f(this, O).setActiveItem(t);
        }
        clearActiveItem() {
          f(this, O) && f(this, O).clearActiveItem();
        }
        getDropdown() {
          let t = this.closest("el-dropdown");
          if (!t)
            throw new Error("[ElMenu] No `<el-dropdown>` element found");
          return t;
        }
        getItems() {
          return Array.from(this.querySelectorAll(`${ue},[role="menuitem"]`));
        }
        getActiveItem() {
          return f(this, O)?.getActiveItem() || null;
        }
        onAttributeChange(t, n, r) {
          switch (t) {
            case "open": {
              r === null ? this.hidePopover() : this.showPopover();
              break;
            }
          }
        }
      };
      O = new WeakMap(), C(St, "observedAttributes", ["anchor", "open"]);
      T("el-menu", St);
      T("el-dropdown", fo);
      Lt = class extends x {
        onAttributeChange(o, t, n) {
          switch (o) {
            case "open": {
              n === null ? this.hidePopover() : this.showPopover();
              break;
            }
          }
        }
        getOptionByName(o) {
          let t = this.querySelector(`el-option[value="${o}"]`);
          return t || null;
        }
        getItems() {
          return Array.from(this.querySelectorAll("el-option:not([disabled])"));
        }
      };
      C(Lt, "observedAttributes", ["anchor", "open"]);
      po = class extends x {
      };
      T("el-options", Lt);
      T("el-option", po);
      mo = class extends x {
        getPopovers() {
          return Array.from(this.querySelectorAll("* > el-popover"));
        }
      };
      It = class extends x {
        mount(o) {
          if (!this.id)
            throw new Error("[ElPopover] No id found for popover (ensure `id` is set)");
          let n = this.getButton();
          n.id || (n.id = P("popover-button")), He(this, () => this.getButton(), () => this.getButton(), o), U(n, "--button-width", o, this), this.setAttribute("tabindex", "-1"), n.addEventListener("keydown", (s) => {
            (s.key === "Enter" || s.key === " ") && (s.preventDefault(), this.togglePopover());
          }, {signal: o});
          let r = this, i = this.closest("el-popover-group");
          i && i.getPopovers().includes(this) && (r = i), xt(r, [n], this, o, () => this.hidePopover()), this.addEventListener("toggle", (s) => {
            let a = s;
            a.newState === "closed" && a.oldState === "open" && setTimeout(() => {
              !this.contains(document.activeElement) && document.activeElement !== document.body || n && n !== document.activeElement && n.isConnected && Pe(n);
            });
          }, {signal: o});
        }
        getButton() {
          let o = this.id, t = document.querySelector(`[popovertarget="${o}"]`);
          if (!t)
            throw new Error('[ElPopover] No button found for popover (ensure you add a `<button popovertarget="${id}">` on the page)');
          return t;
        }
        onAttributeChange(o, t, n) {
          switch (o) {
            case "open": {
              n === null ? this.hidePopover() : this.showPopover();
              break;
            }
          }
        }
      };
      C(It, "observedAttributes", ["anchor", "open"]);
      T("el-popover", It);
      T("el-popover-group", mo);
      ho = class extends x {
        mount(o) {
          let t = this.getList(), n = this.getPanels(), r = t.getTabButtons(), i = n.getPanels();
          if (r.length !== i.length) {
            console.warn("[ElTabGroup] Mismatch between number of tabs and panels");
            return;
          }
          for (let a = 0; a < i.length; a++) {
            let l = i[a], u = r[a];
            u.id || (u.id = P("tailwindplus-tab")), l.id || (l.id = P("tailwindplus-tab-panel")), l.setAttribute("aria-labelledby", u.id), u.setAttribute("aria-controls", l.id), u.setAttribute("role", "tab");
          }
          let s = this.getActiveTab();
          s === -1 && (s = 0), t.setActiveTab(s), n.setActivePanel(s), t.addEventListener("keydown", (a) => {
            switch (a.key) {
              case "ArrowLeft": {
                a.preventDefault();
                let u = this.getActiveTab() - 1;
                u < 0 && (u = r.length - 1), this.setActiveTab(u), r[u].focus();
                break;
              }
              case "ArrowRight": {
                a.preventDefault();
                let u = this.getActiveTab() + 1;
                u >= r.length && (u = 0), this.setActiveTab(u), r[u].focus();
                break;
              }
              case "Home":
              case "PageUp": {
                a.preventDefault(), this.setActiveTab(0), r[0].focus();
                break;
              }
              case "End":
              case "PageDown": {
                a.preventDefault(), this.setActiveTab(r.length - 1), r[r.length - 1].focus();
                break;
              }
            }
          }, {signal: o});
          for (let a = 0; a < r.length; a++)
            r[a].addEventListener("click", (u) => {
              u.preventDefault(), this.setActiveTab(a);
            }, {signal: o});
        }
        getActiveTab() {
          let o = this.querySelector("el-tab-panels"), t = o.getPanels().find((n) => !n.hasAttribute("hidden"));
          return t ? o.getPanels().indexOf(t) : -1;
        }
        getList() {
          let o = this.querySelector("el-tab-list");
          if (!o)
            throw new Error("[ElTabGroup] No `<el-tab-list>` element found");
          return o;
        }
        getPanels() {
          let o = this.querySelector("el-tab-panels");
          if (!o)
            throw new Error("[ElTabGroup] No `<el-tab-panels>` element found");
          return o;
        }
        setActiveTab(o) {
          if (this.getActiveTab() === o)
            return;
          let n = this.getList(), r = this.getPanels(), i = n.getTabButtons();
          o < 0 || o >= i.length || (n.setActiveTab(o), r.setActivePanel(o));
        }
      };
      go = class extends x {
        mount() {
          this.setAttribute("role", "tablist"), this.setAttribute("aria-orientation", "horizontal");
        }
        getTabButtons() {
          let o = this.querySelectorAll("button");
          return Array.from(o);
        }
        setActiveTab(o) {
          this.getTabButtons().forEach((n, r) => {
            let i = r === o;
            n.setAttribute("tabindex", i ? "0" : "-1"), n.setAttribute("aria-selected", i ? "true" : "false");
          });
        }
      };
      bo = class extends x {
        mount() {
          let t = this.getTabGroup().getList(), n = this.getPanels(), r = new MutationObserver((i) => {
            for (let s of i) {
              let a = s.target;
              switch (s.attributeName) {
                case "hidden":
                  if (!a.hasAttribute(s.attributeName)) {
                    let l = n.indexOf(a);
                    t.setActiveTab(l), this.setActivePanel(l);
                  }
              }
            }
          });
          for (let i of n)
            i.setAttribute("role", "tabpanel"), i.setAttribute("tabindex", "0"), r.observe(i, {attributeFilter: ["hidden"], attributes: true});
        }
        getTabGroup() {
          let o = this.closest("el-tab-group");
          if (!o)
            throw new Error("`<el-tab-panels>` must be inside of a `<el-tab-group>` element.");
          return o;
        }
        getPanels() {
          return Array.from(this.children);
        }
        setActivePanel(o) {
          this.getPanels().forEach((n, r) => {
            n.toggleAttribute("hidden", r !== o);
          });
        }
      };
      T("el-tab-list", go);
      T("el-tab-panels", bo);
      T("el-tab-group", ho);
      typeof globalThis.window < "u" && setTimeout(() => window.dispatchEvent(new Event("elements:ready")));
    }
  });

  // js/site.js
  var require_site = __commonJS({
    "js/site.js"() {
      init_dist();
      var CONFIG = {
        skip: {backward: -15, forward: 15, shiftBackward: -30, shiftForward: 30},
        animation: {duration: 300, thresholds: [0, 0.01, 0.05], rootMargin: "20px 0px 20px 0px"},
        localStorage: {audioTTL: 7 * 24 * 60 * 60 * 1e3, readingTTL: 24 * 60 * 60 * 1e3},
        speeds: [1, 1.25, 1.5, 2],
        reading: {minProgress: 0.05, scrollDebounce: 100, restoreDelay: 500, scrollRatio: 0.8}
      };
      var utils = {
        toggleClasses: (element, add, remove) => {
          if (add)
            element.classList.add(...[add].flat());
          if (remove)
            element.classList.remove(...[remove].flat());
        },
        bindEventListeners: (elements, event, handler) => {
          elements.forEach((el) => el.addEventListener(event, handler));
        },
        getElements: (container, selectors) => {
          const result = {};
          Object.entries(selectors).forEach(([key, selector]) => {
            result[key] = container.querySelectorAll(selector);
          });
          return result;
        },
        formatTime: (seconds) => !isFinite(seconds) ? "--:--" : `${Math.floor(seconds / 60)}:${Math.floor(seconds % 60).toString().padStart(2, "0")}`,
        parseUrl: (url) => url?.split("/").pop()?.split(".")[0] || "unknown"
      };
      function initScrollAnimations() {
        const animatedElements = document.querySelectorAll(".animate-reveal, .animate-fade-in, .animate-children");
        const observer = new IntersectionObserver((entries) => {
          entries.forEach((entry) => {
            if (entry.isIntersecting) {
              entry.target.classList.add("run");
              observer.unobserve(entry.target);
            }
          });
        }, {
          threshold: CONFIG.animation.thresholds,
          rootMargin: CONFIG.animation.rootMargin
        });
        animatedElements.forEach((el) => observer.observe(el));
      }
      function initMobileNav() {
        const elements = {
          button: document.getElementById("mobile-menu-button"),
          menu: document.getElementById("mobile-menu"),
          panel: document.getElementById("mobile-menu-panel"),
          close: document.getElementById("mobile-menu-close"),
          backdrop: document.getElementById("mobile-menu-backdrop"),
          menuIcon: document.getElementById("menu-icon"),
          closeIcon: document.getElementById("close-icon")
        };
        if (!elements.button || !elements.menu || !elements.panel)
          return;
        const toggleMenu = (show) => {
          if (show) {
            utils.toggleClasses(elements.menu, null, "hidden");
            utils.toggleClasses(elements.menuIcon, "hidden");
            utils.toggleClasses(elements.closeIcon, null, "hidden");
            document.body.style.overflow = "hidden";
            requestAnimationFrame(() => {
              utils.toggleClasses(elements.panel, "translate-x-0", "translate-x-full");
            });
          } else {
            utils.toggleClasses(elements.panel, "translate-x-full", "translate-x-0");
            setTimeout(() => {
              utils.toggleClasses(elements.menu, "hidden");
              utils.toggleClasses(elements.menuIcon, null, "hidden");
              utils.toggleClasses(elements.closeIcon, "hidden");
              document.body.style.overflow = "";
            }, CONFIG.animation.duration);
          }
        };
        elements.button.addEventListener("click", () => toggleMenu(true));
        elements.close?.addEventListener("click", () => toggleMenu(false));
        elements.backdrop?.addEventListener("click", () => toggleMenu(false));
        document.addEventListener("keydown", (e) => {
          if (e.key === "Escape" && !elements.menu.classList.contains("hidden")) {
            toggleMenu(false);
          }
        });
      }
      function initAudioPlayers() {
        class SermonPlayer {
          constructor(container) {
            this.container = container;
            this.audio = container.querySelector("audio");
            this.currentSpeedIndex = 0;
            const selectors = {
              playPauseBtns: ".play-pause-btn",
              currentTimeElements: ".current-time",
              durationElements: ".duration",
              scrubberElements: ".audio-scrubber",
              progressFillElements: ".progress-fill",
              skipBackBtns: ".skip-back",
              skipForwardBtns: ".skip-forward",
              speedBtns: ".speed-toggle",
              speedTextElements: ".speed-text"
            };
            Object.assign(this, utils.getElements(container, selectors));
            this.playerId = utils.parseUrl(container.dataset.audioUrl || this.audio?.src);
            this.init();
          }
          init() {
            this.setupEventListeners();
            this.loadState();
          }
          setupEventListeners() {
            utils.bindEventListeners(this.playPauseBtns, "click", () => this.togglePlayPause());
            utils.bindEventListeners(this.scrubberElements, "input", (e) => this.seek(e));
            utils.bindEventListeners(this.scrubberElements, "change", (e) => this.seek(e));
            utils.bindEventListeners(this.skipBackBtns, "click", () => this.skip(CONFIG.skip.backward));
            utils.bindEventListeners(this.skipForwardBtns, "click", () => this.skip(CONFIG.skip.forward));
            utils.bindEventListeners(this.speedBtns, "click", () => this.toggleSpeed());
            if (this.audio) {
              const audioEvents = {
                loadedmetadata: () => this.onLoadedMetadata(),
                timeupdate: () => this.onTimeUpdate(),
                ended: () => this.onEnded(),
                error: () => this.onError(),
                loadstart: () => this.onLoadStart()
              };
              Object.entries(audioEvents).forEach(([event, handler]) => {
                this.audio.addEventListener(event, handler);
              });
            }
            this.container.addEventListener("keydown", (e) => this.handleKeyboard(e));
            if ("mediaSession" in navigator) {
              this.setupMediaSession();
            }
          }
          togglePlayPause() {
            this.audio.paused ? this.play() : this.pause();
          }
          async play() {
            try {
              await this.audio.play();
              this.updatePlayPauseButton("playing");
              this.saveState();
            } catch (error) {
              console.error("Error playing audio:", error);
              this.onError();
            }
          }
          pause() {
            this.audio.pause();
            this.updatePlayPauseButton("paused");
            this.saveState();
          }
          seek(event) {
            const scrubber = event.target;
            const percent = scrubber.value / 100;
            const time = percent * this.audio.duration;
            if (isFinite(time)) {
              this.audio.currentTime = time;
              this.saveState();
            }
          }
          skip(seconds) {
            if (this.audio.duration) {
              const newTime = Math.max(0, Math.min(this.audio.currentTime + seconds, this.audio.duration));
              this.audio.currentTime = newTime;
              this.saveState();
            }
          }
          updateSpeedText(speed) {
            this.speedTextElements.forEach((el) => {
              el.textContent = speed === 1 ? "1\xD7" : `${speed}\xD7`;
            });
          }
          toggleSpeed() {
            this.currentSpeedIndex = (this.currentSpeedIndex + 1) % CONFIG.speeds.length;
            const speed = CONFIG.speeds[this.currentSpeedIndex];
            this.audio.playbackRate = speed;
            this.updateSpeedText(speed);
            this.saveState();
          }
          updatePlayPauseButton(state) {
            const isPlaying = state === "playing";
            this.playPauseBtns.forEach((btn) => {
              const playIcon = btn.querySelector(".play-icon");
              const pauseIcon = btn.querySelector(".pause-icon");
              if (playIcon)
                utils.toggleClasses(playIcon, isPlaying ? "hidden" : null, isPlaying ? null : "hidden");
              if (pauseIcon)
                utils.toggleClasses(pauseIcon, isPlaying ? null : "hidden", isPlaying ? "hidden" : null);
              btn.setAttribute("aria-label", isPlaying ? "Pause sermon" : "Play sermon");
              btn.dataset.state = state;
            });
          }
          updateProgress() {
            if (this.audio.duration) {
              const percent = this.audio.currentTime / this.audio.duration * 100;
              this.progressFillElements.forEach((fill) => {
                fill.style.width = `${percent}%`;
              });
              this.scrubberElements.forEach((scrubber) => {
                scrubber.value = percent;
                scrubber.setAttribute("aria-valuenow", Math.round(percent));
              });
            }
          }
          updateTime() {
            this.currentTimeElements.forEach((el) => {
              el.textContent = utils.formatTime(this.audio.currentTime);
            });
            if (this.audio.duration) {
              this.durationElements.forEach((el) => {
                el.textContent = utils.formatTime(this.audio.duration);
              });
            }
          }
          onLoadStart() {
          }
          onLoadedMetadata() {
            this.updateTime();
            this.restoreState();
          }
          onTimeUpdate() {
            this.updateProgress();
            this.updateTime();
          }
          onEnded() {
            this.updatePlayPauseButton("paused");
            this.audio.currentTime = 0;
            this.updateProgress();
          }
          onError() {
            console.error("Audio playback error");
          }
          saveState() {
            const state = {
              currentTime: this.audio.currentTime,
              playbackRate: this.audio.playbackRate,
              speedIndex: this.currentSpeedIndex,
              lastPlayed: Date.now()
            };
            localStorage.setItem(`sermon-${this.playerId}`, JSON.stringify(state));
          }
          loadState() {
            const saved = localStorage.getItem(`sermon-${this.playerId}`);
            if (saved) {
              this.savedState = JSON.parse(saved);
            }
          }
          restoreState() {
            if (!this.savedState)
              return;
            if (this.savedState.playbackRate) {
              this.audio.playbackRate = this.savedState.playbackRate;
              this.currentSpeedIndex = this.savedState.speedIndex || 0;
              this.updateSpeedText(CONFIG.speeds[this.currentSpeedIndex]);
            }
            const isRecent = this.savedState.lastPlayed && Date.now() - this.savedState.lastPlayed < CONFIG.localStorage.audioTTL;
            if (isRecent && this.savedState.currentTime > 5) {
              this.audio.currentTime = this.savedState.currentTime;
              this.updateProgress();
              this.updateTime();
            }
          }
          handleKeyboard(event) {
            if (!this.container.contains(document.activeElement))
              return;
            const keyActions = {
              " ": () => this.togglePlayPause(),
              "ArrowLeft": () => this.skip(event.shiftKey ? CONFIG.skip.shiftBackward : CONFIG.skip.backward),
              "ArrowRight": () => this.skip(event.shiftKey ? CONFIG.skip.shiftForward : CONFIG.skip.forward)
            };
            const action = keyActions[event.key];
            if (action) {
              event.preventDefault();
              action();
            }
          }
          setupMediaSession() {
            const title = this.container.querySelector(".player-header h3")?.textContent || "Sermon";
            const scripture = this.container.querySelector(".player-header p")?.textContent || "";
            navigator.mediaSession.metadata = new MediaMetadata({
              title,
              artist: "Saints Church",
              album: scripture,
              artwork: [
                {src: "/assets/icons/apple-touch-icon.png", sizes: "180x180", type: "image/png"}
              ]
            });
            const handlers = {
              play: () => this.play(),
              pause: () => this.pause(),
              seekbackward: () => this.skip(CONFIG.skip.backward),
              seekforward: () => this.skip(CONFIG.skip.forward)
            };
            Object.entries(handlers).forEach(([action, handler]) => {
              navigator.mediaSession.setActionHandler(action, handler);
            });
          }
        }
        const players = document.querySelectorAll(".sermon-player");
        players.forEach((player) => new SermonPlayer(player));
      }
      function initTranscriptionEnhancements() {
        const elements = {
          transcription: document.getElementById("sermon-transcription"),
          progressIndicator: document.getElementById("reading-progress"),
          transcriptDetails: document.querySelector(".transcript-details")
        };
        if (elements.transcriptDetails?.hasAttribute("open")) {
          setTimeout(() => elements.transcriptDetails.removeAttribute("open"), 100);
        }
        if (!elements.transcription)
          return;
        const state = {lastScrollPosition: 0, ticking: false};
        const readingUtils = {
          savePosition: (progress) => {
            localStorage.setItem(`reading-${location.pathname}`, JSON.stringify({
              progress,
              timestamp: Date.now()
            }));
          },
          restorePosition: () => {
            const saved = localStorage.getItem(`reading-${location.pathname}`);
            if (!saved)
              return;
            try {
              const data = JSON.parse(saved);
              const isRecent = data.timestamp > Date.now() - CONFIG.localStorage.readingTTL;
              const hasProgress = data.progress > CONFIG.reading.minProgress;
              if (isRecent && hasProgress) {
                const documentHeight = document.documentElement.scrollHeight - window.innerHeight;
                const targetScroll = data.progress * documentHeight;
                setTimeout(() => {
                  window.scrollTo({top: targetScroll, behavior: "smooth"});
                }, CONFIG.reading.restoreDelay);
              }
            } catch (e) {
            }
          },
          updateProgress: () => {
            const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
            const documentHeight = document.documentElement.scrollHeight - window.innerHeight;
            const progress = Math.min(Math.max(scrollTop / documentHeight, 0), 1);
            if (elements.progressIndicator) {
              const progressBar = elements.progressIndicator.querySelector("div");
              if (progressBar)
                progressBar.style.height = `${progress * 100}%`;
            }
            if (Math.abs(scrollTop - state.lastScrollPosition) > CONFIG.reading.scrollDebounce) {
              state.lastScrollPosition = scrollTop;
              readingUtils.savePosition(progress);
            }
            state.ticking = false;
          },
          onScroll: () => {
            if (!state.ticking) {
              requestAnimationFrame(readingUtils.updateProgress);
              state.ticking = true;
            }
          },
          handleKeyboard: (event) => {
            if (["INPUT", "TEXTAREA"].includes(event.target.tagName))
              return;
            const shortcuts = {
              "Home": () => elements.transcription.scrollIntoView({behavior: "smooth", block: "start"}),
              "End": () => window.scrollTo({top: document.body.scrollHeight, behavior: "smooth"}),
              "PageUp": () => window.scrollBy({top: -window.innerHeight * CONFIG.reading.scrollRatio, behavior: "smooth"}),
              "PageDown": () => window.scrollBy({top: window.innerHeight * CONFIG.reading.scrollRatio, behavior: "smooth"})
            };
            const action = shortcuts[event.key];
            if (action) {
              event.preventDefault();
              action();
            }
          }
        };
        if (elements.transcription.scrollHeight > window.innerHeight * 2) {
          elements.progressIndicator?.classList.remove("hidden");
          window.addEventListener("scroll", readingUtils.onScroll, {passive: true});
          document.addEventListener("keydown", readingUtils.handleKeyboard);
          readingUtils.restorePosition();
        }
      }
      var initAll = () => {
        initScrollAnimations();
        initMobileNav();
        initAudioPlayers();
        initTranscriptionEnhancements();
      };
      document.readyState === "loading" ? document.addEventListener("DOMContentLoaded", initAll) : initAll();
    }
  });
  require_site();
})();
/*! @tailwindplus/elements v1.0.13 | Proprietary License | https://tailwindcss.com/plus/license */
//# sourceMappingURL=site.min.js.map
