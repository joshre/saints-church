# Saints Church Podcast Sync Workflow
#
# This workflow automatically syncs sermon episodes from the Saints Church RSS feed
# (https://anchor.fm/s/f5d78a70/podcast/rss) to Jekyll posts in the _posts/ directory.
#
# Key Features:
# - Parses RSS feed for episode metadata (title, description, audio URL, duration, GUID)
# - Creates Jekyll posts with proper frontmatter (layout: sermon, scripture references, series detection)
# - Prevents duplicates using GUID tracking in _data/processed_episodes.json
# - Scheduled to run weekly on Sundays at 9:00 AM UTC (after sermon uploads)
# - Optimized for Reformed Baptist context with enhanced scripture reference extraction
# - Automated commits with descriptive messages including episode titles
#
# Reformed Baptist Context:
# - Automatically detects biblical book series for expository preaching (John, Galatians, etc.)
# - Enhanced scripture reference patterns for confessional Baptist sermons
# - Pastor Nate Ellis attribution with fallback to RSS feed author
#
# File Structure:
# - Posts: _posts/YYYY-MM-DD-scripture-reference.md
# - Tracking: _data/processed_episodes.json (GUID duplicate prevention)
# - Layout: Uses "sermon" layout with comprehensive frontmatter
#
# Manual Trigger: Can be triggered manually via GitHub Actions "workflow_dispatch"

name: Sync Podcast Episodes

on:
  schedule:
    # Run weekly on Sundays at 9:00 AM UTC (4:00 AM EST / 5:00 AM EDT)
    # This timing allows for sermon uploads after Sunday service
    - cron: '0 9 * * 0'
  workflow_dispatch: # Allow manual triggering

permissions:
  contents: write

jobs:
  sync-podcast:
    runs-on: ubuntu-latest

    # Prevent concurrent workflow runs to avoid file conflicts
    concurrency:
      group: podcast-sync
      cancel-in-progress: false

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Create package.json for dependencies
        run: |
          cat > package.json << 'EOF'
          {
            "name": "podcast-sync",
            "version": "1.0.0",
            "dependencies": {
              "rss-parser": "^3.13.0"
            }
          }
          EOF

      - name: Install dependencies
        run: npm install

      - name: Create processed episodes tracking file
        run: |
          mkdir -p _data
          if [ ! -f "_data/processed_episodes.json" ]; then
            echo "[]" > _data/processed_episodes.json
          fi

      - name: Create posts directory
        run: mkdir -p _posts

      - name: Sync podcast episodes
        run: |
          cat > sync-episodes.js << 'EOF'
          const Parser = require('rss-parser');
          const fs = require('fs');
          const path = require('path');
          const crypto = require('crypto');

          const parser = new Parser({
            customFields: {
              item: [
                'guid',
                'enclosure',
                'itunes:duration',
                'itunes:author',
                'itunes:summary'
              ]
            }
          });

          const RSS_URL = 'https://anchor.fm/s/f5d78a70/podcast/rss';
          const PROCESSED_FILE = '_data/processed_episodes.json';
          const POSTS_DIR = '_posts';

          // Constants
          const NETWORK_TIMEOUT = 30000;
          const CONTENT_HASH_LENGTH = 16;
          const EPISODE_HASH_LENGTH = 8;
          const DEFAULT_PASTOR = 'Pastor Nate Ellis';
          const MAX_FILENAME_LENGTH = 100;

          // Memory optimization constants
          const MAX_FEED_ITEMS = 1000; // Reasonable limit for RSS feeds
          const MAX_CONTENT_LENGTH = 1024 * 1024; // 1MB per episode content
          const MEMORY_CHECK_INTERVAL = 10; // Check memory every N episodes
          const MAX_MEMORY_MB = 250; // Warning threshold in MB

          // File operation safety utilities
          function withFileLock(filepath, operation) {
            const lockFile = `${filepath}.lock`;
            const maxWaitTime = 30000; // 30 seconds
            const checkInterval = 100; // 100ms
            let waitTime = 0;

            // Wait for any existing lock to be released
            while (fs.existsSync(lockFile) && waitTime < maxWaitTime) {
              const lockStat = fs.statSync(lockFile);
              const lockAge = Date.now() - lockStat.mtime.getTime();

              // Break stale locks older than 5 minutes
              if (lockAge > 300000) {
                console.warn(`Breaking stale lock file: ${lockFile}`);
                fs.unlinkSync(lockFile);
                break;
              }

              // Wait and retry
              const sleepMs = Math.min(checkInterval, maxWaitTime - waitTime);
              const start = Date.now();
              while (Date.now() - start < sleepMs) {
                // Busy wait (simple sleep simulation)
              }
              waitTime += sleepMs;
            }

            if (fs.existsSync(lockFile)) {
              throw new Error(`Could not acquire lock for ${filepath} after ${maxWaitTime}ms`);
            }

            // Create lock
            try {
              fs.writeFileSync(lockFile, process.pid.toString(), { flag: 'wx' });
            } catch (error) {
              if (error.code === 'EEXIST') {
                throw new Error(`Lock file ${lockFile} already exists`);
              }
              throw error;
            }

            try {
              return operation();
            } finally {
              // Always remove lock
              try {
                fs.unlinkSync(lockFile);
              } catch (error) {
                console.warn(`Failed to remove lock file ${lockFile}:`, error.message);
              }
            }
          }

          function writeFileAtomic(filepath, content, options = {}) {
            const tempFile = `${filepath}.tmp.${Date.now()}.${Math.random().toString(36).substring(2)}`;

            try {
              // Write to temporary file first
              fs.writeFileSync(tempFile, content, { ...options, mode: options.mode || 0o644 });

              // Atomic rename (this is the atomic operation)
              fs.renameSync(tempFile, filepath);

              console.log(`Atomically wrote file: ${path.basename(filepath)}`);
            } catch (error) {
              // Clean up temp file if something went wrong
              try {
                if (fs.existsSync(tempFile)) {
                  fs.unlinkSync(tempFile);
                }
              } catch (cleanupError) {
                console.warn(`Failed to clean up temp file ${tempFile}:`, cleanupError.message);
              }
              throw error;
            }
          }

          function createBackup(filepath) {
            if (!fs.existsSync(filepath)) return null;

            const backupPath = `${filepath}.backup.${Date.now()}`;
            try {
              fs.copyFileSync(filepath, backupPath);
              console.log(`Created backup: ${path.basename(backupPath)}`);
              return backupPath;
            } catch (error) {
              console.warn(`Failed to create backup of ${filepath}:`, error.message);
              return null;
            }
          }

          // Load processed episodes with file locking
          function loadProcessedEpisodes() {
            return withFileLock(PROCESSED_FILE, () => {
              try {
                if (fs.existsSync(PROCESSED_FILE)) {
                  const data = fs.readFileSync(PROCESSED_FILE, 'utf8');
                  const parsed = JSON.parse(data);

                  // Validate structure
                  if (!Array.isArray(parsed)) {
                    throw new Error('Processed episodes file does not contain valid array');
                  }

                  return parsed;
                }
              } catch (error) {
                console.log('Error loading processed episodes:', error.message);

                // Try to load from backup if main file is corrupted
                const backupFiles = fs.readdirSync(path.dirname(PROCESSED_FILE) || '.')
                  .filter(f => f.startsWith(path.basename(PROCESSED_FILE) + '.backup.'))
                  .sort()
                  .reverse(); // Most recent first

                for (const backupFile of backupFiles.slice(0, 3)) { // Try last 3 backups
                  try {
                    const backupPath = path.join(path.dirname(PROCESSED_FILE) || '.', backupFile);
                    console.log(`Attempting to restore from backup: ${backupFile}`);
                    const backupData = fs.readFileSync(backupPath, 'utf8');
                    const parsed = JSON.parse(backupData);

                    if (Array.isArray(parsed)) {
                      console.log(`Successfully restored from backup: ${backupFile}`);
                      return parsed;
                    }
                  } catch (backupError) {
                    console.warn(`Backup ${backupFile} also corrupted:`, backupError.message);
                  }
                }
              }
              return [];
            });
          }

          // Save processed episodes with file locking and atomic operations
          function saveProcessedEpisodes(episodes) {
            return withFileLock(PROCESSED_FILE, () => {
              try {
                // Validate input
                if (!Array.isArray(episodes)) {
                  throw new Error('Episodes must be an array');
                }

                // Create backup before overwriting
                const backupPath = createBackup(PROCESSED_FILE);

                // Atomic write
                const content = JSON.stringify(episodes, null, 2);
                writeFileAtomic(PROCESSED_FILE, content);

                console.log(`Saved ${episodes.length} processed episodes to tracking file`);

                // Clean up old backups (keep last 5)
                try {
                  const backupFiles = fs.readdirSync(path.dirname(PROCESSED_FILE) || '.')
                    .filter(f => f.startsWith(path.basename(PROCESSED_FILE) + '.backup.'))
                    .sort()
                    .reverse(); // Most recent first

                  // Remove old backups beyond the last 5
                  for (const oldBackup of backupFiles.slice(5)) {
                    const oldBackupPath = path.join(path.dirname(PROCESSED_FILE) || '.', oldBackup);
                    fs.unlinkSync(oldBackupPath);
                    console.log(`Cleaned up old backup: ${oldBackup}`);
                  }
                } catch (cleanupError) {
                  console.warn('Failed to clean up old backups:', cleanupError.message);
                }

              } catch (error) {
                console.error('Error saving processed episodes:', error.message);
                throw error; // Re-throw to trigger failure handling
              }
            });
          }

          // Generate content hash for change detection
          function generateContentHash(episode) {
            const contentToHash = [
              episode.title,
              episode.description || episode['itunes:summary'] || '',
              episode.enclosure?.url || '',
              episode['itunes:duration'] || '',
              episode['itunes:author'] || ''
            ].join('|');
            return crypto.createHash('sha256').update(contentToHash).digest('hex').substring(0, CONTENT_HASH_LENGTH);
          }

          // Pre-compiled regex patterns for performance (avoid recompilation)
          const SCRIPTURE_PATTERNS = (() => {
            // Optimize patterns for performance - most specific first, case-insensitive but not global
            return [
              // Most common Reformed pattern: "Book Chapter" or "Book Chapter:Verse"
              /\b(Genesis|Exodus|Leviticus|Numbers|Deuteronomy|Joshua|Judges|Ruth|1\s*Samuel|2\s*Samuel|1\s*Kings|2\s*Kings|1\s*Chronicles|2\s*Chronicles|Ezra|Nehemiah|Esther|Job|Psalms?|Proverbs|Ecclesiastes|Song\s+of\s+Songs|Song\s+of\s+Solomon|Isaiah|Jeremiah|Lamentations|Ezekiel|Daniel|Hosea|Joel|Amos|Obadiah|Jonah|Micah|Nahum|Habakkuk|Zephaniah|Haggai|Zechariah|Malachi|Matthew|Mark|Luke|John|Acts|Romans|1\s*Corinthians|2\s*Corinthians|Galatians|Ephesians|Philippians|Colossians|1\s*Thessalonians|2\s*Thessalonians|1\s*Timothy|2\s*Timothy|Titus|Philemon|Hebrews|James|1\s*Peter|2\s*Peter|1\s*John|2\s*John|3\s*John|Jude|Revelation)\s+\d+(?::\d+(?:[-‚Äì]\d+)?)?(?:[-‚Äì]\d+:\d+)?\b/i,

              // Abbreviated forms (common in sermon titles)
              /\b(?:Gen|Ex|Exod|Lev|Num|Deut|Josh|Judg|1\s*Sam|2\s*Sam|1\s*Kgs|2\s*Kgs|1\s*Chr|2\s*Chr|Ezr|Neh|Est|Ps|Prov|Eccl|Song|Isa|Jer|Lam|Ezek|Dan|Hos|Joel|Amos|Obad|Jonah|Mic|Nah|Hab|Zeph|Hag|Zech|Mal|Matt|Mk|Lk|Jn|Acts|Rom|1\s*Cor|2\s*Cor|Gal|Eph|Phil|Col|1\s*Thess|2\s*Thess|1\s*Tim|2\s*Tim|Tit|Phlm|Heb|Jas|1\s*Pet|2\s*Pet|1\s*Jn|2\s*Jn|3\s*Jn|Jude|Rev)\.?\s+\d+(?::\d+(?:[-‚Äì]\d+)?)?(?:[-‚Äì]\d+:\d+)?\b/i,

              // Roman numeral books (less common, check after standard forms)
              /\b(?:I|II|III|IV)\s+(?:Samuel|Kings|Chronicles|Corinthians|Thessalonians|Timothy|Peter|John)\s+\d+(?::\d+(?:[-‚Äì]\d+)?)?(?:[-‚Äì]\d+:\d+)?\b/i,

              // Single chapter books (least common, check last)
              /\b(?:Obadiah|Philemon|2\s*John|3\s*John|Jude)\s*(?:v\.?\s*\d+(?:[-‚Äì]\d+)?)?\b/i
            ];
          })();

          // Memory optimization utilities
          function getMemoryUsage() {
            const usage = process.memoryUsage();
            return {
              rss: Math.round(usage.rss / 1024 / 1024), // MB
              heapUsed: Math.round(usage.heapUsed / 1024 / 1024), // MB
              heapTotal: Math.round(usage.heapTotal / 1024 / 1024), // MB
              external: Math.round(usage.external / 1024 / 1024) // MB
            };
          }

          function checkMemoryUsage(context = '') {
            const usage = getMemoryUsage();
            const totalMemory = usage.rss;

            if (totalMemory > MAX_MEMORY_MB) {
              console.warn(`‚ö†Ô∏è  High memory usage ${context}: ${totalMemory}MB (RSS), ${usage.heapUsed}MB (Heap)`);

              if (totalMemory > MAX_MEMORY_MB * 1.5) {
                console.error(`‚ùå Critical memory usage ${context}: ${totalMemory}MB - forcing garbage collection`);
                if (global.gc) {
                  global.gc();
                  const afterGC = getMemoryUsage();
                  console.log(`üßπ After GC: ${afterGC.rss}MB (RSS), ${afterGC.heapUsed}MB (Heap)`);
                }
              }
            }

            return totalMemory;
          }

          function sanitizeContentLength(content, maxLength = MAX_CONTENT_LENGTH) {
            if (!content || typeof content !== 'string') return content;

            if (content.length > maxLength) {
              console.warn(`‚ö†Ô∏è  Large content detected (${content.length} chars), truncating to ${maxLength} chars`);
              return content.substring(0, maxLength) + '\n\n[Content truncated due to size limits]';
            }

            return content;
          }

          function optimizeFeedData(feed) {
            if (!feed || !feed.items) return feed;

            // Limit number of items to prevent memory issues
            if (feed.items.length > MAX_FEED_ITEMS) {
              console.warn(`‚ö†Ô∏è  Large feed detected (${feed.items.length} items), limiting to ${MAX_FEED_ITEMS} most recent items`);
              feed.items = feed.items.slice(0, MAX_FEED_ITEMS);
            }

            // Sanitize large content in feed items
            let truncatedCount = 0;
            feed.items.forEach(item => {
              const originalLength = (item.content || '').length + (item.description || '').length + (item['itunes:summary'] || '').length;

              item.content = sanitizeContentLength(item.content);
              item.description = sanitizeContentLength(item.description);
              item['itunes:summary'] = sanitizeContentLength(item['itunes:summary']);

              const newLength = (item.content || '').length + (item.description || '').length + (item['itunes:summary'] || '').length;

              if (newLength < originalLength) {
                truncatedCount++;
              }

              // Remove unnecessary large fields to save memory
              delete item.contentSnippet;
              delete item.isoDate;
              if (item.itunes) {
                delete item.itunes.image;
                delete item.itunes.owner;
              }
            });

            if (truncatedCount > 0) {
              console.log(`üìè Truncated content in ${truncatedCount} episodes to prevent memory issues`);
            }

            return feed;
          }

          // Memoization cache for scripture extraction (avoid repeated parsing)
          const scriptureCache = new Map();
          const MAX_CACHE_SIZE = 50; // Reduced cache size for memory optimization

          // Extract scripture references from title or description - optimized version
          function extractScripture(text) {
            if (!text || typeof text !== 'string') return null;

            // Normalize text for consistent caching (trim and limit length for cache key)
            const cacheKey = text.trim().substring(0, 200);

            // Check cache first
            if (scriptureCache.has(cacheKey)) {
              return scriptureCache.get(cacheKey);
            }

            // Quick pre-filter: if text doesn't contain digits, it's unlikely to be a scripture reference
            if (!/\d/.test(text)) {
              scriptureCache.set(cacheKey, null);
              return null;
            }

            // Test patterns in order of likelihood (most common first)
            for (const pattern of SCRIPTURE_PATTERNS) {
              const match = pattern.exec(text);
              if (match) {
                // Clean up the reference
                let reference = match[0].trim();
                // Normalize whitespace and standardize dashes
                reference = reference.replace(/\s+/g, ' ').replace(/[‚Äì‚Äî]/g, '-');

                // Cache the result with size limit
                if (scriptureCache.size >= MAX_CACHE_SIZE) {
                  // Remove oldest entry (first in Map insertion order)
                  const firstKey = scriptureCache.keys().next().value;
                  scriptureCache.delete(firstKey);
                }
                scriptureCache.set(cacheKey, reference);

                return reference;
              }
            }

            // Cache negative results too to avoid repeated failed parsing
            scriptureCache.set(cacheKey, null);
            return null;
          }

          // Calculate the Sunday on or before the given date (sermon date)
          function getSermonSunday(date) {
            const day = new Date(date);
            const dayOfWeek = day.getDay(); // 0 = Sunday, 1 = Monday, etc.

            // If it's already Sunday (0), use that date
            // Otherwise, go back to the previous Sunday
            const daysToSubtract = dayOfWeek;
            const sermonDate = new Date(day);
            sermonDate.setDate(day.getDate() - daysToSubtract);

            return sermonDate;
          }

          // Parse duration from various formats
          function parseDuration(duration) {
            if (!duration || typeof duration !== 'string') return null;

            // Handle MM:SS or HH:MM:SS format
            const parts = duration.split(':').map(p => parseInt(p, 10));

            // Validate that all parts are valid numbers
            if (parts.some(p => isNaN(p))) {
              return null;
            }

            if (parts.length === 2) {
              // MM:SS
              const [minutes, seconds] = parts;
              return `${minutes}:${seconds.toString().padStart(2, '0')}`;
            } else if (parts.length === 3) {
              // HH:MM:SS
              const [hours, minutes, seconds] = parts;
              if (hours > 0) {
                return `${hours}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
              } else {
                return `${minutes}:${seconds.toString().padStart(2, '0')}`;
              }
            }

            return duration;
          }

          // Generate Jekyll filename from date and title
          function generateFilename(date, title) {
            const dateStr = date.toISOString().split('T')[0];
            let slug = title
              .toLowerCase()
              .replace(/[^\w\s-]/g, '') // Remove special characters
              .replace(/\s+/g, '-') // Replace spaces with hyphens
              .replace(/-+/g, '-') // Replace multiple hyphens with single
              .replace(/^-|-$/g, '') // Remove leading/trailing hyphens
              .substring(0, MAX_FILENAME_LENGTH); // Limit length to prevent filesystem issues

            // Ensure slug is not empty
            if (!slug) {
              slug = 'untitled-sermon';
            }

            return `${dateStr}-${slug}.md`;
          }


          // Detect pastor name from description text (e.g. "This sermon was preached by Evan Burress.")
          function detectPastor(text) {
            if (!text) return null;
            const match = text.match(/[Pp]reached by ([A-Z][a-zA-Z]+(?: [A-Z][a-zA-Z]+)+)/);
            return match ? match[1] : null;
          }

          // Parse existing frontmatter to preserve custom fields
          function parseExistingFrontmatter(content) {
            if (!content) return {};

            const frontmatterMatch = content.match(/^---\r?\n([\s\S]*?)\r?\n---/);
            if (!frontmatterMatch) return {};

            const frontmatterText = frontmatterMatch[1];
            const parsed = {};

            // Simple YAML parser for our use case
            const lines = frontmatterText.split('\n');
            for (const line of lines) {
              const match = line.match(/^(\w+):\s*"?([^"]*)"?$/);
              if (match) {
                const [, key, value] = match;
                parsed[key] = value.replace(/^"/, '').replace(/"$/, '');
              }
            }

            return parsed;
          }

          // Generate frontmatter and content for Jekyll post
          function generatePost(episode, existingContent = null) {
            const pubDate = new Date(episode.pubDate);
            const sermonDate = getSermonSunday(pubDate); // Use sermon Sunday instead of publish date
            const scripture = extractScripture(episode.title) || extractScripture(episode.description);
            const duration = parseDuration(episode['itunes:duration']);

            // Parse existing frontmatter to preserve custom fields
            const existingFrontmatter = parseExistingFrontmatter(existingContent);

            // Extract series from title with Reformed Baptist context
            let series = null;

            // Method 1: Look for patterns like "Series Name: Episode Title"
            const seriesMatch = episode.title.match(/^([^:]+):\s*(.+)$/);
            if (seriesMatch) {
              const potentialSeries = seriesMatch[1].trim();
              // Only treat as series if it's not a scripture reference
              if (!extractScripture(potentialSeries)) {
                series = potentialSeries;
              }
            }

            // Method 2: Detect common biblical book series for expository preaching
            if (!series && scripture) {
              const bookMatch = scripture.match(/^(.*?)\s+\d+/);
              if (bookMatch) {
                const book = bookMatch[1].trim();
                // Common series names for expository preaching through books
                if (['John', 'Galatians', 'Romans', 'Ephesians', 'Matthew', 'Mark', 'Luke', 'Acts', 'Genesis', 'Exodus'].includes(book)) {
                  series = book;
                }
              }
            }

            // Clean RSS description content and convert HTML to markdown
            function cleanDescription(text) {
              if (!text || typeof text !== 'string') return null;

              return text
                // Convert HTML entities first
                .replace(/&nbsp;/gi, ' ')
                .replace(/&amp;/gi, '&')
                .replace(/&lt;/gi, '<')
                .replace(/&gt;/gi, '>')
                .replace(/&quot;/gi, '"')
                // Convert HTML to markdown
                .replace(/<p>/gi, '\n\n')      // Paragraph start
                .replace(/<\/p>/gi, '')        // Paragraph end
                .replace(/<br\s*\/?>/gi, '\n') // Line breaks
                .replace(/<[^>]+>/g, '')       // Remove any other HTML tags
                // Convert bullets to markdown
                .replace(/‚Ä¢/g, '-')            // Bullet to dash
                .replace(/^\s*-/gm, '-')       // Normalize leading dashes
                // Clean up whitespace
                .replace(/\n{3,}/g, '\n\n')    // Max 2 newlines
                .replace(/\n\s+/g, '\n')       // Remove leading spaces after newlines
                .trim() || null;
            }

            // Generate unique hash for audio player progress tracking
            const episodeHash = crypto.createHash('sha256').update(episode.guid || episode.link || episode.title).digest('hex').substring(0, EPISODE_HASH_LENGTH);

            // Build new frontmatter, preserving custom fields from existing content
            const frontmatter = {
              layout: 'sermon',
              title: episode.title,
              date: sermonDate.toISOString(),
              category: 'sermon',
              audio_url: episode.enclosure?.url || null,
              duration: duration,
              scripture: scripture,
              series: series,
              pastor: existingFrontmatter.pastor || detectPastor(episode.description || episode['itunes:summary'] || '') || DEFAULT_PASTOR,
              description: cleanDescription(episode.description || episode['itunes:summary'] || ''),
              guid: episode.guid,
              episode_id: episodeHash,
              // Preserve custom fields that aren't from RSS
              transcription_model: existingFrontmatter.transcription_model || null
            };

            // Remove null values
            Object.keys(frontmatter).forEach(key => {
              if (frontmatter[key] === null) {
                delete frontmatter[key];
              }
            });

            // Secure YAML escaping function
            function escapeYAMLValue(value) {
              if (typeof value !== 'string') return value;

              return value
                .replace(/\\/g, '\\\\')     // Escape backslashes first
                .replace(/"/g, '\\"')       // Escape quotes
                .replace(/\n/g, '\\n')      // Escape newlines
                .replace(/\r/g, '\\r')      // Escape carriage returns
                .replace(/\t/g, '\\t')      // Escape tabs
                .replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]/g, '') // Remove control characters
                .replace(/[\u0080-\u009F]/g, '') // Remove C1 control characters
                .trim(); // Remove leading/trailing whitespace
            }

            let content = '---\n';
            Object.entries(frontmatter).forEach(([key, value]) => {
              if (typeof value === 'string') {
                const safeKey = key.replace(/[^a-zA-Z0-9_-]/g, '');

                // Only use quotes if value contains special YAML characters
                const needsQuotes = /[:\n\r"'@`#\[\]{}|>*&!%]/.test(value) ||
                                   value.startsWith(' ') ||
                                   value.endsWith(' ') ||
                                   value === '' ||
                                   /^\d+$/.test(value); // Numbers as strings

                if (needsQuotes) {
                  const escapedValue = escapeYAMLValue(value);
                  content += `${safeKey}: "${escapedValue}"\n`;
                } else {
                  content += `${safeKey}: ${value}\n`;
                }
              } else {
                content += `${key}: ${value}\n`;
              }
            });
            content += '---\n\n';

            // Preserve existing transcription content if it exists
            if (existingContent) {
              // Robust content preservation with multiple fallback patterns
              const preservationPatterns = [
                // Standard frontmatter with double newline
                /^---[\s\S]*?---\r?\n\r?\n([\s\S]*)$/,
                // Frontmatter with single newline (malformed but common)
                /^---[\s\S]*?---\r?\n([\s\S]*)$/,
                // Frontmatter with extra whitespace
                /^---[\s\S]*?---\s+([\s\S]*)$/
              ];

              for (const pattern of preservationPatterns) {
                const existingBodyMatch = existingContent.match(pattern);
                if (existingBodyMatch && existingBodyMatch[1].trim()) {
                  // Keep existing body content (transcriptions)
                  console.log(`Preserved ${existingBodyMatch[1].trim().length} characters of existing content`);
                  content += existingBodyMatch[1];
                  return content;
                }
              }

              // If no pattern matches but content exists, log warning
              if (existingContent.trim()) {
                console.warn('Could not parse existing frontmatter to preserve content');
              }
            }

            // Add episode content only for new files (avoid duplication)
            if (episode.content || episode['itunes:summary']) {
              const episodeContent = episode.content || episode['itunes:summary'];
              const description = episode.description || '';

              // Only add if content is meaningfully different (not just whitespace/formatting)
              const normalizeText = (text) => text.replace(/\s+/g, ' ').trim().toLowerCase();
              if (normalizeText(episodeContent) !== normalizeText(description) && episodeContent.length > 50) {
                // Escape YAML content properly
                const escapedContent = episodeContent.replace(/\\/g, '\\\\').replace(/---/g, '\\-\\-\\-');
                content += `${escapedContent}\n`;
              }
            }

            return content;
          }

          // Enhanced error handling utilities
          function isRetryableError(error) {
            // Network errors, timeouts, and temporary file system issues
            const retryableErrors = [
              'ECONNRESET', 'ECONNREFUSED', 'ENOTFOUND', 'ETIMEDOUT',
              'EHOSTUNREACH', 'ENETUNREACH', 'EAI_AGAIN', 'EBUSY', 'EMFILE', 'ENFILE'
            ];

            const retryableMessages = [
              'timeout', 'network', 'fetch', 'connection', 'temporary'
            ];

            if (error.code && retryableErrors.includes(error.code)) {
              return true;
            }

            if (error.message) {
              const message = error.message.toLowerCase();
              return retryableMessages.some(keyword => message.includes(keyword));
            }

            return false;
          }

          async function withRetry(operation, options = {}) {
            const {
              maxRetries = 3,
              baseDelay = 1000,
              maxDelay = 10000,
              backoffMultiplier = 2,
              operationName = 'operation'
            } = options;

            let lastError;
            let delay = baseDelay;

            for (let attempt = 1; attempt <= maxRetries + 1; attempt++) {
              try {
                const result = await operation();
                if (attempt > 1) {
                  console.log(`${operationName} succeeded on attempt ${attempt}`);
                }
                return result;
              } catch (error) {
                lastError = error;

                if (attempt === maxRetries + 1) {
                  console.error(`${operationName} failed after ${maxRetries} retries:`, error.message);
                  break;
                }

                if (!isRetryableError(error)) {
                  console.error(`${operationName} failed with non-retryable error:`, error.message);
                  break;
                }

                console.warn(`${operationName} failed (attempt ${attempt}/${maxRetries + 1}): ${error.message}`);
                console.log(`Retrying in ${delay}ms...`);

                // Wait with exponential backoff
                await new Promise(resolve => setTimeout(resolve, delay));
                delay = Math.min(delay * backoffMultiplier, maxDelay);
              }
            }

            throw lastError;
          }

          async function fetchRSSFeedWithRetry() {
            return withRetry(async () => {
              console.log(`Fetching RSS feed from: ${RSS_URL}`);
              const initialMemory = checkMemoryUsage('before RSS fetch');

              // Create parser with timeout
              const feedPromise = parser.parseURL(RSS_URL);
              const timeoutPromise = new Promise((_, reject) =>
                setTimeout(() => reject(new Error(`RSS feed fetch timeout after ${NETWORK_TIMEOUT / 1000} seconds`)), NETWORK_TIMEOUT)
              );

              const rawFeed = await Promise.race([feedPromise, timeoutPromise]);

              // Validate feed structure
              if (!rawFeed || !rawFeed.items || !Array.isArray(rawFeed.items)) {
                throw new Error('Invalid RSS feed structure: missing or invalid items array');
              }

              console.log(`Successfully fetched RSS feed with ${rawFeed.items.length} episodes`);
              checkMemoryUsage('after RSS fetch');

              // Optimize feed data for memory efficiency
              const optimizedFeed = optimizeFeedData(rawFeed);

              const finalMemory = checkMemoryUsage('after feed optimization');
              const memoryDelta = finalMemory - initialMemory;

              if (memoryDelta > 0) {
                console.log(`üíæ Feed processing used ${memoryDelta}MB of memory`);
              }

              return optimizedFeed;
            }, {
              maxRetries: 3,
              baseDelay: 2000,
              maxDelay: 15000,
              operationName: 'RSS feed fetch'
            });
          }

          async function syncEpisodes() {
            const startTime = Date.now();
            let processedCount = 0;
            let errorCount = 0;
            const errors = [];

            try {
              const feed = await fetchRSSFeedWithRetry();
              console.log(`Found ${feed.items.length} episodes in RSS feed`);

              const processedEpisodes = loadProcessedEpisodes();
              // Build map efficiently without intermediate array
              const processedMap = processedEpisodes.reduce((map, ep) => {
                map.set(ep.guid, ep);
                return map;
              }, new Map());

              let newEpisodes = 0;
              let updatedEpisodes = 0;

              // Process episodes with enhanced error handling and memory monitoring
              const totalEpisodes = feed.items.length;
              console.log(`üìÑ Processing ${totalEpisodes} episodes with memory monitoring...`);

              for (let index = 0; index < totalEpisodes; index++) {
                const item = feed.items[index];
                const episodeNumber = index + 1;

                // Periodic memory monitoring and cleanup
                if (episodeNumber % MEMORY_CHECK_INTERVAL === 0) {
                  checkMemoryUsage(`after processing ${episodeNumber}/${totalEpisodes} episodes`);

                  // Clear caches periodically to free memory
                  if (scriptureCache.size > MAX_CACHE_SIZE * 0.8) {
                    const cacheSize = scriptureCache.size;
                    scriptureCache.clear();
                    console.log(`üßπ Cleared scripture cache (${cacheSize} entries) to free memory`);
                  }

                  // Force garbage collection if available and memory is high
                  const currentMemory = getMemoryUsage().rss;
                  if (global.gc && currentMemory > MAX_MEMORY_MB) {
                    global.gc();
                    console.log(`üßπ Forced garbage collection at episode ${episodeNumber}`);
                  }
                }

                try {
                  // Validate required fields with detailed error messages
                  if (!item.title || typeof item.title !== 'string' || !item.title.trim()) {
                    const error = new Error(`Episode ${episodeNumber}: Missing or invalid title`);
                    errors.push(error);
                    errorCount++;
                    console.warn(`Skipping episode ${episodeNumber}/${totalEpisodes}: ${error.message}`);
                    continue;
                  }

                  const guid = item.guid || item.link;
                  if (!guid) {
                    const error = new Error(`Episode "${item.title}": Missing GUID and link`);
                    errors.push(error);
                    errorCount++;
                    console.warn(`Skipping episode ${episodeNumber}/${totalEpisodes}: ${error.message}`);
                    continue;
                  }

                  const currentContentHash = generateContentHash(item);
                  const existingEpisode = processedMap.get(guid);

                  if (existingEpisode) {
                    // Check if content has changed
                    if (existingEpisode.content_hash && existingEpisode.content_hash === currentContentHash) {
                      console.log(`No changes for episode ${episodeNumber}/${totalEpisodes}: ${item.title}`);
                      processedCount++;
                      continue;
                    } else {
                      console.log(`Content updated for episode ${episodeNumber}/${totalEpisodes}: ${item.title}`);
                    }
                  } else {
                    console.log(`Processing new episode ${episodeNumber}/${totalEpisodes}: ${item.title}`);
                  }

                  // Process individual episode with retry logic for file operations
                  await withRetry(async () => {
                    const pubDate = new Date(item.pubDate);
                    if (isNaN(pubDate.getTime())) {
                      throw new Error(`Invalid publication date: ${item.pubDate}`);
                    }

                    const sermonDate = getSermonSunday(pubDate);
                    const filename = generateFilename(sermonDate, item.title);

                    // Log date adjustment if sermon date differs from publish date
                    if (sermonDate.toDateString() !== pubDate.toDateString()) {
                      console.log(`Adjusted sermon date: ${item.title} - Published: ${pubDate.toDateString()}, Sermon: ${sermonDate.toDateString()}`);
                    }

                    // Validate filename
                    if (!filename || filename.endsWith('-.md')) {
                      throw new Error(`Invalid filename generated from title: ${item.title}`);
                    }

                    // Prevent path traversal attacks
                    if (filename.includes('..') || filename.includes('/') || filename.includes('\\')) {
                      throw new Error(`Unsafe filename detected: ${filename}`);
                    }

                    const filepath = path.join(POSTS_DIR, filename);

                    // Read existing content to preserve transcriptions
                    let existingContent = null;
                    if (existingEpisode) {
                      // Try to read from the existing file location (in case filename changed)
                      const existingFilepath = existingEpisode.filename ?
                        path.join(POSTS_DIR, existingEpisode.filename) :
                        filepath;

                      if (fs.existsSync(existingFilepath)) {
                        try {
                          existingContent = fs.readFileSync(existingFilepath, 'utf8');
                          console.log(`Preserving content from: ${existingEpisode.filename || filename}`);
                        } catch (error) {
                          console.warn(`Could not read existing file ${existingFilepath}: ${error.message}`);
                        }
                      }
                    }

                    const postContent = generatePost(item, existingContent);

                    // Create backup of existing file before overwriting
                    let backupPath = null;
                    if (fs.existsSync(filepath)) {
                      backupPath = createBackup(filepath);
                    }

                    // Atomic file write operation
                    try {
                      writeFileAtomic(filepath, postContent);
                    } catch (writeError) {
                      // Restore from backup if write failed
                      if (backupPath && fs.existsSync(backupPath)) {
                        try {
                          fs.copyFileSync(backupPath, filepath);
                          console.log(`Restored file from backup after write failure: ${path.basename(filepath)}`);
                        } catch (restoreError) {
                          console.error(`Failed to restore from backup: ${restoreError.message}`);
                        }
                      }
                      throw writeError;
                    }

                    // If this is an update and filename has changed, safely delete the old file
                    if (existingEpisode && existingEpisode.filename && existingEpisode.filename !== filename) {
                      const oldFilepath = path.join(POSTS_DIR, existingEpisode.filename);
                      if (fs.existsSync(oldFilepath)) {
                        try {
                          // Create backup before deletion
                          const oldBackupPath = createBackup(oldFilepath);
                          fs.unlinkSync(oldFilepath);
                          console.log(`Deleted old file: ${existingEpisode.filename}`);

                          // Clean up backup after successful deletion (keep it for 1 minute just in case)
                          if (oldBackupPath) {
                            setTimeout(() => {
                              try {
                                if (fs.existsSync(oldBackupPath)) {
                                  fs.unlinkSync(oldBackupPath);
                                }
                              } catch (cleanupError) {
                                console.warn(`Failed to cleanup deletion backup: ${cleanupError.message}`);
                              }
                            }, 60000); // 1 minute
                          }
                        } catch (deleteError) {
                          console.error(`Failed to delete old file ${existingEpisode.filename}: ${deleteError.message}`);
                          // Don't fail the entire process for deletion errors
                        }
                      }
                    }

                    console.log(`${existingEpisode ? 'Updated' : 'Created'} post: ${filename}`);

                    // Update or add to processed episodes
                    const episodeRecord = {
                      guid: guid,
                      title: item.title,
                      filename: filename,
                      content_hash: currentContentHash,
                      processed_at: new Date().toISOString()
                    };

                    // Update the map for future lookups
                    processedMap.set(guid, episodeRecord);

                    // Increment counters only after successful processing
                    if (existingEpisode) {
                      updatedEpisodes++;
                    } else {
                      newEpisodes++;
                    }

                    processedCount++;
                  }, {
                    maxRetries: 2,
                    baseDelay: 1000,
                    maxDelay: 5000,
                    operationName: `processing episode "${item.title}"`
                  });

                } catch (error) {
                  const detailedError = new Error(`Episode ${episodeNumber}/${totalEpisodes} "${item.title}": ${error.message}`);
                  errors.push(detailedError);
                  errorCount++;
                  console.error(`Failed to process episode ${episodeNumber}/${totalEpisodes}:`, error.message);

                  // Continue processing other episodes unless it's a critical error
                  if (error.message.includes('ENOSPC') || error.message.includes('quota')) {
                    console.error('Critical disk space error detected, stopping processing');
                    break;
                  }
                }
              }

              // Save processed episodes with enhanced error handling
              try {
                const finalProcessedEpisodes = Array.from(processedMap.values());
                await withRetry(async () => {
                  saveProcessedEpisodes(finalProcessedEpisodes);
                }, {
                  maxRetries: 3,
                  baseDelay: 1000,
                  operationName: 'saving processed episodes'
                });

                // Final cleanup and memory reporting
                scriptureCache.clear();
                if (global.gc) {
                  global.gc();
                }

                const finalMemory = getMemoryUsage();
                const executionTime = ((Date.now() - startTime) / 1000).toFixed(1);

                console.log(`\nüìä Sync Summary:`);
                console.log(`‚è±Ô∏è  Execution time: ${executionTime}s`);
                console.log(`üìÑ Total episodes in feed: ${feed.items.length}`);
                console.log(`‚úÖ Successfully processed: ${processedCount}`);
                console.log(`üÜï New episodes created: ${newEpisodes}`);
                console.log(`üîÑ Updated episodes: ${updatedEpisodes}`);
                console.log(`üíæ Total tracked episodes: ${finalProcessedEpisodes.length}`);
                console.log(`üìä Final memory usage: ${finalMemory.rss}MB (RSS), ${finalMemory.heapUsed}MB (Heap)`);

                if (errorCount > 0) {
                  console.log(`\n‚ö†Ô∏è  Errors encountered: ${errorCount}`);
                  console.log(`üìù Error details:`);
                  errors.slice(0, 5).forEach((error, index) => {
                    console.log(`   ${index + 1}. ${error.message}`);
                  });
                  if (errors.length > 5) {
                    console.log(`   ... and ${errors.length - 5} more errors`);
                  }
                }

                // Set output for GitHub Actions with comprehensive metrics
                if (process.env.GITHUB_OUTPUT) {
                  const outputLines = [
                    `new_episodes=${newEpisodes}`,
                    `updated_episodes=${updatedEpisodes}`,
                    `total_episodes=${feed.items.length}`,
                    `processed_count=${processedCount}`,
                    `error_count=${errorCount}`,
                    `execution_time=${((Date.now() - startTime) / 1000).toFixed(1)}`,
                    `success=${errorCount === 0 ? 'true' : 'partial'}`
                  ];

                  for (const line of outputLines) {
                    fs.appendFileSync(process.env.GITHUB_OUTPUT, `${line}\n`);
                  }
                }

                // Determine exit status based on results
                if (errorCount === 0) {
                  console.log(`\n‚úÖ Sync completed successfully!`);
                } else if (processedCount > 0) {
                  console.log(`\n‚ö†Ô∏è  Sync completed with ${errorCount} errors (${processedCount} episodes processed successfully)`);
                  // Exit with warning code but don't fail the workflow for partial success
                  process.exit(0);
                } else {
                  console.log(`\n‚ùå Sync failed - no episodes were processed successfully`);
                  process.exit(1);
                }

              } catch (saveError) {
                console.error('‚ùå Critical error saving processed episodes:', saveError.message);
                console.error('This may cause duplicate processing on next run');

                // Still report what we accomplished
                console.log(`\nüìä Partial Results (before save failure):`);
                console.log(`‚è±Ô∏è  Execution time: ${((Date.now() - startTime) / 1000).toFixed(1)}s`);
                console.log(`‚úÖ Episodes processed: ${processedCount}`);
                console.log(`üÜï New episodes: ${newEpisodes}`);
                console.log(`üîÑ Updated episodes: ${updatedEpisodes}`);

                throw saveError;
              }

            } catch (error) {
              const executionTime = ((Date.now() - startTime) / 1000).toFixed(1);
              console.error(`\n‚ùå Critical sync failure after ${executionTime}s:`, error.message);

              // Provide context for debugging
              if (error.stack) {
                console.error('Stack trace:', error.stack);
              }

              // Report partial progress if any
              if (processedCount > 0) {
                console.log(`\nüìä Partial progress before failure:`);
                console.log(`‚úÖ Episodes processed: ${processedCount}`);
                console.log(`üÜï New episodes: ${newEpisodes}`);
                console.log(`üîÑ Updated episodes: ${updatedEpisodes}`);
              }

              process.exit(1);
            }
          }

          // Run the sync
          syncEpisodes();
          EOF

          node sync-episodes.js

      - name: Regenerate taxonomy pages
        run: npx tsx scripts/generate-taxonomies.ts

      - name: Commit episode changes
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"

          # Check if there are any changes
          if [ -n "$(git status --porcelain)" ]; then
            git add _posts/ _data/processed_episodes.json sermons/preachers/ sermons/series/

            # Count new, modified, and deleted files
            NEW_FILES=$(git diff --cached --name-status | grep "^A" | grep "_posts/" | wc -l)
            MODIFIED_FILES=$(git diff --cached --name-status | grep "^M" | grep "_posts/" | wc -l)
            DELETED_FILES=$(git diff --cached --name-status | grep "^D" | grep "_posts/" | wc -l)

            # Adjust counts: if we have equal deletions and additions, treat as updates
            if [ "$DELETED_FILES" -gt 0 ] && [ "$NEW_FILES" -gt 0 ]; then
              RENAMES=$((NEW_FILES < DELETED_FILES ? NEW_FILES : DELETED_FILES))
              NEW_FILES=$((NEW_FILES - RENAMES))
              MODIFIED_FILES=$((MODIFIED_FILES + RENAMES))
            fi

            if [ "$NEW_FILES" -gt 0 ] || [ "$MODIFIED_FILES" -gt 0 ]; then
              # Get the titles for commit message (safely)
              CHANGED_TITLES=$(git diff --cached --name-only | grep "_posts/" | head -5 | while read file; do basename "$file" .md | sed 's/^[0-9]\{4\}-[0-9]\{2\}-[0-9]\{2\}-//' | sed 's/-/ /g' | sed 's/[^a-zA-Z0-9 :.-]//g'; done | tr '\n' '|')

              # Build commit message based on changes
              if [ "$NEW_FILES" -gt 0 ] && [ "$MODIFIED_FILES" -eq 0 ]; then
                # Only new episodes
                if [ "$NEW_FILES" -eq 1 ]; then
                  FIRST_TITLE=$(echo "$CHANGED_TITLES" | cut -d'|' -f1)
                  git commit -m "Add new sermon: $FIRST_TITLE" -m "Automated podcast sync from Saints Church RSS feed"
                else
                  git commit -m "Add $NEW_FILES new sermon episodes" -m "$(echo "$CHANGED_TITLES" | tr '|' '\n' | sed 's/^/- /' | head -5)" -m "Automated podcast sync"
                fi
              elif [ "$NEW_FILES" -eq 0 ] && [ "$MODIFIED_FILES" -gt 0 ]; then
                # Only updated episodes
                if [ "$MODIFIED_FILES" -eq 1 ]; then
                  FIRST_TITLE=$(echo "$CHANGED_TITLES" | cut -d'|' -f1)
                  git commit -m "Update sermon: $FIRST_TITLE" -m "Automated podcast sync from Saints Church RSS feed"
                else
                  git commit -m "Update $MODIFIED_FILES sermon episodes" -m "$(echo "$CHANGED_TITLES" | tr '|' '\n' | sed 's/^/- /' | head -5)" -m "Automated podcast sync"
                fi
              else
                # Both new and updated episodes
                git commit -m "Sync sermons: $NEW_FILES new, $MODIFIED_FILES updated" -m "$(echo "$CHANGED_TITLES" | tr '|' '\n' | sed 's/^/- /' | head -5)" -m "Automated podcast sync"
              fi
              echo "Committed $NEW_FILES new episode(s) and $MODIFIED_FILES updated episode(s)"
            else
              echo "No episodes to commit"
            fi
          else
            echo "No changes detected"
          fi

      - name: Push changes
        run: |
          if [ -n "$(git log @{u}.. --oneline 2>/dev/null)" ]; then
            git push
            echo "Pushed changes to repository"
          else
            echo "No changes to push"
          fi